
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model pais
 * 
 */
export type pais = $Result.DefaultSelection<Prisma.$paisPayload>
/**
 * Model indicador
 * 
 */
export type indicador = $Result.DefaultSelection<Prisma.$indicadorPayload>
/**
 * Model saude
 * 
 */
export type saude = $Result.DefaultSelection<Prisma.$saudePayload>
/**
 * Model economia
 * 
 */
export type economia = $Result.DefaultSelection<Prisma.$economiaPayload>
/**
 * Model ambiente
 * 
 */
export type ambiente = $Result.DefaultSelection<Prisma.$ambientePayload>
/**
 * Model tecnologia
 * 
 */
export type tecnologia = $Result.DefaultSelection<Prisma.$tecnologiaPayload>
/**
 * Model demografia
 * 
 */
export type demografia = $Result.DefaultSelection<Prisma.$demografiaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const categoria: {
  Saude: 'Saude',
  Economia: 'Economia',
  Ambiente: 'Ambiente',
  Tecnologia: 'Tecnologia',
  Demografia: 'Demografia'
};

export type categoria = (typeof categoria)[keyof typeof categoria]

}

export type categoria = $Enums.categoria

export const categoria: typeof $Enums.categoria

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Pais
 * const pais = await prisma.pais.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Pais
   * const pais = await prisma.pais.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.pais`: Exposes CRUD operations for the **pais** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pais
    * const pais = await prisma.pais.findMany()
    * ```
    */
  get pais(): Prisma.paisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.indicador`: Exposes CRUD operations for the **indicador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Indicadors
    * const indicadors = await prisma.indicador.findMany()
    * ```
    */
  get indicador(): Prisma.indicadorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saude`: Exposes CRUD operations for the **saude** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saudes
    * const saudes = await prisma.saude.findMany()
    * ```
    */
  get saude(): Prisma.saudeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.economia`: Exposes CRUD operations for the **economia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Economias
    * const economias = await prisma.economia.findMany()
    * ```
    */
  get economia(): Prisma.economiaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ambiente`: Exposes CRUD operations for the **ambiente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ambientes
    * const ambientes = await prisma.ambiente.findMany()
    * ```
    */
  get ambiente(): Prisma.ambienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tecnologia`: Exposes CRUD operations for the **tecnologia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tecnologias
    * const tecnologias = await prisma.tecnologia.findMany()
    * ```
    */
  get tecnologia(): Prisma.tecnologiaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.demografia`: Exposes CRUD operations for the **demografia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Demografias
    * const demografias = await prisma.demografia.findMany()
    * ```
    */
  get demografia(): Prisma.demografiaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    pais: 'pais',
    indicador: 'indicador',
    saude: 'saude',
    economia: 'economia',
    ambiente: 'ambiente',
    tecnologia: 'tecnologia',
    demografia: 'demografia'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "pais" | "indicador" | "saude" | "economia" | "ambiente" | "tecnologia" | "demografia"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      pais: {
        payload: Prisma.$paisPayload<ExtArgs>
        fields: Prisma.paisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          findFirst: {
            args: Prisma.paisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          findMany: {
            args: Prisma.paisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>[]
          }
          create: {
            args: Prisma.paisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          createMany: {
            args: Prisma.paisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>[]
          }
          delete: {
            args: Prisma.paisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          update: {
            args: Prisma.paisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          deleteMany: {
            args: Prisma.paisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>[]
          }
          upsert: {
            args: Prisma.paisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          aggregate: {
            args: Prisma.PaisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePais>
          }
          groupBy: {
            args: Prisma.paisGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaisGroupByOutputType>[]
          }
          count: {
            args: Prisma.paisCountArgs<ExtArgs>
            result: $Utils.Optional<PaisCountAggregateOutputType> | number
          }
        }
      }
      indicador: {
        payload: Prisma.$indicadorPayload<ExtArgs>
        fields: Prisma.indicadorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.indicadorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.indicadorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload>
          }
          findFirst: {
            args: Prisma.indicadorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.indicadorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload>
          }
          findMany: {
            args: Prisma.indicadorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload>[]
          }
          create: {
            args: Prisma.indicadorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload>
          }
          createMany: {
            args: Prisma.indicadorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.indicadorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload>[]
          }
          delete: {
            args: Prisma.indicadorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload>
          }
          update: {
            args: Prisma.indicadorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload>
          }
          deleteMany: {
            args: Prisma.indicadorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.indicadorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.indicadorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload>[]
          }
          upsert: {
            args: Prisma.indicadorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$indicadorPayload>
          }
          aggregate: {
            args: Prisma.IndicadorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicador>
          }
          groupBy: {
            args: Prisma.indicadorGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicadorGroupByOutputType>[]
          }
          count: {
            args: Prisma.indicadorCountArgs<ExtArgs>
            result: $Utils.Optional<IndicadorCountAggregateOutputType> | number
          }
        }
      }
      saude: {
        payload: Prisma.$saudePayload<ExtArgs>
        fields: Prisma.saudeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saudeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saudeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload>
          }
          findFirst: {
            args: Prisma.saudeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saudeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload>
          }
          findMany: {
            args: Prisma.saudeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload>[]
          }
          create: {
            args: Prisma.saudeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload>
          }
          createMany: {
            args: Prisma.saudeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.saudeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload>[]
          }
          delete: {
            args: Prisma.saudeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload>
          }
          update: {
            args: Prisma.saudeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload>
          }
          deleteMany: {
            args: Prisma.saudeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saudeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.saudeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload>[]
          }
          upsert: {
            args: Prisma.saudeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saudePayload>
          }
          aggregate: {
            args: Prisma.SaudeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaude>
          }
          groupBy: {
            args: Prisma.saudeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaudeGroupByOutputType>[]
          }
          count: {
            args: Prisma.saudeCountArgs<ExtArgs>
            result: $Utils.Optional<SaudeCountAggregateOutputType> | number
          }
        }
      }
      economia: {
        payload: Prisma.$economiaPayload<ExtArgs>
        fields: Prisma.economiaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.economiaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.economiaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload>
          }
          findFirst: {
            args: Prisma.economiaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.economiaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload>
          }
          findMany: {
            args: Prisma.economiaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload>[]
          }
          create: {
            args: Prisma.economiaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload>
          }
          createMany: {
            args: Prisma.economiaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.economiaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload>[]
          }
          delete: {
            args: Prisma.economiaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload>
          }
          update: {
            args: Prisma.economiaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload>
          }
          deleteMany: {
            args: Prisma.economiaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.economiaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.economiaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload>[]
          }
          upsert: {
            args: Prisma.economiaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$economiaPayload>
          }
          aggregate: {
            args: Prisma.EconomiaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEconomia>
          }
          groupBy: {
            args: Prisma.economiaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EconomiaGroupByOutputType>[]
          }
          count: {
            args: Prisma.economiaCountArgs<ExtArgs>
            result: $Utils.Optional<EconomiaCountAggregateOutputType> | number
          }
        }
      }
      ambiente: {
        payload: Prisma.$ambientePayload<ExtArgs>
        fields: Prisma.ambienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ambienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ambienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload>
          }
          findFirst: {
            args: Prisma.ambienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ambienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload>
          }
          findMany: {
            args: Prisma.ambienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload>[]
          }
          create: {
            args: Prisma.ambienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload>
          }
          createMany: {
            args: Prisma.ambienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ambienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload>[]
          }
          delete: {
            args: Prisma.ambienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload>
          }
          update: {
            args: Prisma.ambienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload>
          }
          deleteMany: {
            args: Prisma.ambienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ambienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ambienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload>[]
          }
          upsert: {
            args: Prisma.ambienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ambientePayload>
          }
          aggregate: {
            args: Prisma.AmbienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmbiente>
          }
          groupBy: {
            args: Prisma.ambienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmbienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ambienteCountArgs<ExtArgs>
            result: $Utils.Optional<AmbienteCountAggregateOutputType> | number
          }
        }
      }
      tecnologia: {
        payload: Prisma.$tecnologiaPayload<ExtArgs>
        fields: Prisma.tecnologiaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tecnologiaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tecnologiaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          findFirst: {
            args: Prisma.tecnologiaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tecnologiaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          findMany: {
            args: Prisma.tecnologiaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>[]
          }
          create: {
            args: Prisma.tecnologiaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          createMany: {
            args: Prisma.tecnologiaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tecnologiaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>[]
          }
          delete: {
            args: Prisma.tecnologiaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          update: {
            args: Prisma.tecnologiaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          deleteMany: {
            args: Prisma.tecnologiaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tecnologiaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tecnologiaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>[]
          }
          upsert: {
            args: Prisma.tecnologiaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          aggregate: {
            args: Prisma.TecnologiaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTecnologia>
          }
          groupBy: {
            args: Prisma.tecnologiaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TecnologiaGroupByOutputType>[]
          }
          count: {
            args: Prisma.tecnologiaCountArgs<ExtArgs>
            result: $Utils.Optional<TecnologiaCountAggregateOutputType> | number
          }
        }
      }
      demografia: {
        payload: Prisma.$demografiaPayload<ExtArgs>
        fields: Prisma.demografiaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.demografiaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.demografiaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload>
          }
          findFirst: {
            args: Prisma.demografiaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.demografiaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload>
          }
          findMany: {
            args: Prisma.demografiaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload>[]
          }
          create: {
            args: Prisma.demografiaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload>
          }
          createMany: {
            args: Prisma.demografiaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.demografiaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload>[]
          }
          delete: {
            args: Prisma.demografiaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload>
          }
          update: {
            args: Prisma.demografiaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload>
          }
          deleteMany: {
            args: Prisma.demografiaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.demografiaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.demografiaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload>[]
          }
          upsert: {
            args: Prisma.demografiaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$demografiaPayload>
          }
          aggregate: {
            args: Prisma.DemografiaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDemografia>
          }
          groupBy: {
            args: Prisma.demografiaGroupByArgs<ExtArgs>
            result: $Utils.Optional<DemografiaGroupByOutputType>[]
          }
          count: {
            args: Prisma.demografiaCountArgs<ExtArgs>
            result: $Utils.Optional<DemografiaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    pais?: paisOmit
    indicador?: indicadorOmit
    saude?: saudeOmit
    economia?: economiaOmit
    ambiente?: ambienteOmit
    tecnologia?: tecnologiaOmit
    demografia?: demografiaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PaisCountOutputType
   */

  export type PaisCountOutputType = {
    saude: number
    economia: number
    ambiente: number
    tecnologia: number
    demografia: number
  }

  export type PaisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saude?: boolean | PaisCountOutputTypeCountSaudeArgs
    economia?: boolean | PaisCountOutputTypeCountEconomiaArgs
    ambiente?: boolean | PaisCountOutputTypeCountAmbienteArgs
    tecnologia?: boolean | PaisCountOutputTypeCountTecnologiaArgs
    demografia?: boolean | PaisCountOutputTypeCountDemografiaArgs
  }

  // Custom InputTypes
  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaisCountOutputType
     */
    select?: PaisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeCountSaudeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saudeWhereInput
  }

  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeCountEconomiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: economiaWhereInput
  }

  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeCountAmbienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ambienteWhereInput
  }

  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeCountTecnologiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tecnologiaWhereInput
  }

  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeCountDemografiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: demografiaWhereInput
  }


  /**
   * Count Type IndicadorCountOutputType
   */

  export type IndicadorCountOutputType = {
    saude: number
    economia: number
    ambiente: number
    tecnologia: number
    demografia: number
  }

  export type IndicadorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saude?: boolean | IndicadorCountOutputTypeCountSaudeArgs
    economia?: boolean | IndicadorCountOutputTypeCountEconomiaArgs
    ambiente?: boolean | IndicadorCountOutputTypeCountAmbienteArgs
    tecnologia?: boolean | IndicadorCountOutputTypeCountTecnologiaArgs
    demografia?: boolean | IndicadorCountOutputTypeCountDemografiaArgs
  }

  // Custom InputTypes
  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicadorCountOutputType
     */
    select?: IndicadorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeCountSaudeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saudeWhereInput
  }

  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeCountEconomiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: economiaWhereInput
  }

  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeCountAmbienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ambienteWhereInput
  }

  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeCountTecnologiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tecnologiaWhereInput
  }

  /**
   * IndicadorCountOutputType without action
   */
  export type IndicadorCountOutputTypeCountDemografiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: demografiaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model pais
   */

  export type AggregatePais = {
    _count: PaisCountAggregateOutputType | null
    _min: PaisMinAggregateOutputType | null
    _max: PaisMaxAggregateOutputType | null
  }

  export type PaisMinAggregateOutputType = {
    id: string | null
    nome: string | null
    iso3: string | null
  }

  export type PaisMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    iso3: string | null
  }

  export type PaisCountAggregateOutputType = {
    id: number
    nome: number
    iso3: number
    _all: number
  }


  export type PaisMinAggregateInputType = {
    id?: true
    nome?: true
    iso3?: true
  }

  export type PaisMaxAggregateInputType = {
    id?: true
    nome?: true
    iso3?: true
  }

  export type PaisCountAggregateInputType = {
    id?: true
    nome?: true
    iso3?: true
    _all?: true
  }

  export type PaisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pais to aggregate.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pais
    **/
    _count?: true | PaisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaisMaxAggregateInputType
  }

  export type GetPaisAggregateType<T extends PaisAggregateArgs> = {
        [P in keyof T & keyof AggregatePais]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePais[P]>
      : GetScalarType<T[P], AggregatePais[P]>
  }




  export type paisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paisWhereInput
    orderBy?: paisOrderByWithAggregationInput | paisOrderByWithAggregationInput[]
    by: PaisScalarFieldEnum[] | PaisScalarFieldEnum
    having?: paisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaisCountAggregateInputType | true
    _min?: PaisMinAggregateInputType
    _max?: PaisMaxAggregateInputType
  }

  export type PaisGroupByOutputType = {
    id: string
    nome: string
    iso3: string
    _count: PaisCountAggregateOutputType | null
    _min: PaisMinAggregateOutputType | null
    _max: PaisMaxAggregateOutputType | null
  }

  type GetPaisGroupByPayload<T extends paisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaisGroupByOutputType[P]>
            : GetScalarType<T[P], PaisGroupByOutputType[P]>
        }
      >
    >


  export type paisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    iso3?: boolean
    saude?: boolean | pais$saudeArgs<ExtArgs>
    economia?: boolean | pais$economiaArgs<ExtArgs>
    ambiente?: boolean | pais$ambienteArgs<ExtArgs>
    tecnologia?: boolean | pais$tecnologiaArgs<ExtArgs>
    demografia?: boolean | pais$demografiaArgs<ExtArgs>
    _count?: boolean | PaisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pais"]>

  export type paisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    iso3?: boolean
  }, ExtArgs["result"]["pais"]>

  export type paisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    iso3?: boolean
  }, ExtArgs["result"]["pais"]>

  export type paisSelectScalar = {
    id?: boolean
    nome?: boolean
    iso3?: boolean
  }

  export type paisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "iso3", ExtArgs["result"]["pais"]>
  export type paisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saude?: boolean | pais$saudeArgs<ExtArgs>
    economia?: boolean | pais$economiaArgs<ExtArgs>
    ambiente?: boolean | pais$ambienteArgs<ExtArgs>
    tecnologia?: boolean | pais$tecnologiaArgs<ExtArgs>
    demografia?: boolean | pais$demografiaArgs<ExtArgs>
    _count?: boolean | PaisCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type paisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type paisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $paisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pais"
    objects: {
      saude: Prisma.$saudePayload<ExtArgs>[]
      economia: Prisma.$economiaPayload<ExtArgs>[]
      ambiente: Prisma.$ambientePayload<ExtArgs>[]
      tecnologia: Prisma.$tecnologiaPayload<ExtArgs>[]
      demografia: Prisma.$demografiaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      iso3: string
    }, ExtArgs["result"]["pais"]>
    composites: {}
  }

  type paisGetPayload<S extends boolean | null | undefined | paisDefaultArgs> = $Result.GetResult<Prisma.$paisPayload, S>

  type paisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaisCountAggregateInputType | true
    }

  export interface paisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pais'], meta: { name: 'pais' } }
    /**
     * Find zero or one Pais that matches the filter.
     * @param {paisFindUniqueArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paisFindUniqueArgs>(args: SelectSubset<T, paisFindUniqueArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pais that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paisFindUniqueOrThrowArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paisFindUniqueOrThrowArgs>(args: SelectSubset<T, paisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisFindFirstArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paisFindFirstArgs>(args?: SelectSubset<T, paisFindFirstArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pais that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisFindFirstOrThrowArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paisFindFirstOrThrowArgs>(args?: SelectSubset<T, paisFindFirstOrThrowArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pais
     * const pais = await prisma.pais.findMany()
     * 
     * // Get first 10 Pais
     * const pais = await prisma.pais.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paisWithIdOnly = await prisma.pais.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paisFindManyArgs>(args?: SelectSubset<T, paisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pais.
     * @param {paisCreateArgs} args - Arguments to create a Pais.
     * @example
     * // Create one Pais
     * const Pais = await prisma.pais.create({
     *   data: {
     *     // ... data to create a Pais
     *   }
     * })
     * 
     */
    create<T extends paisCreateArgs>(args: SelectSubset<T, paisCreateArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pais.
     * @param {paisCreateManyArgs} args - Arguments to create many Pais.
     * @example
     * // Create many Pais
     * const pais = await prisma.pais.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paisCreateManyArgs>(args?: SelectSubset<T, paisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pais and returns the data saved in the database.
     * @param {paisCreateManyAndReturnArgs} args - Arguments to create many Pais.
     * @example
     * // Create many Pais
     * const pais = await prisma.pais.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pais and only return the `id`
     * const paisWithIdOnly = await prisma.pais.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paisCreateManyAndReturnArgs>(args?: SelectSubset<T, paisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pais.
     * @param {paisDeleteArgs} args - Arguments to delete one Pais.
     * @example
     * // Delete one Pais
     * const Pais = await prisma.pais.delete({
     *   where: {
     *     // ... filter to delete one Pais
     *   }
     * })
     * 
     */
    delete<T extends paisDeleteArgs>(args: SelectSubset<T, paisDeleteArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pais.
     * @param {paisUpdateArgs} args - Arguments to update one Pais.
     * @example
     * // Update one Pais
     * const pais = await prisma.pais.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paisUpdateArgs>(args: SelectSubset<T, paisUpdateArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pais.
     * @param {paisDeleteManyArgs} args - Arguments to filter Pais to delete.
     * @example
     * // Delete a few Pais
     * const { count } = await prisma.pais.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paisDeleteManyArgs>(args?: SelectSubset<T, paisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pais
     * const pais = await prisma.pais.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paisUpdateManyArgs>(args: SelectSubset<T, paisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pais and returns the data updated in the database.
     * @param {paisUpdateManyAndReturnArgs} args - Arguments to update many Pais.
     * @example
     * // Update many Pais
     * const pais = await prisma.pais.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pais and only return the `id`
     * const paisWithIdOnly = await prisma.pais.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paisUpdateManyAndReturnArgs>(args: SelectSubset<T, paisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pais.
     * @param {paisUpsertArgs} args - Arguments to update or create a Pais.
     * @example
     * // Update or create a Pais
     * const pais = await prisma.pais.upsert({
     *   create: {
     *     // ... data to create a Pais
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pais we want to update
     *   }
     * })
     */
    upsert<T extends paisUpsertArgs>(args: SelectSubset<T, paisUpsertArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisCountArgs} args - Arguments to filter Pais to count.
     * @example
     * // Count the number of Pais
     * const count = await prisma.pais.count({
     *   where: {
     *     // ... the filter for the Pais we want to count
     *   }
     * })
    **/
    count<T extends paisCountArgs>(
      args?: Subset<T, paisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaisAggregateArgs>(args: Subset<T, PaisAggregateArgs>): Prisma.PrismaPromise<GetPaisAggregateType<T>>

    /**
     * Group by Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paisGroupByArgs['orderBy'] }
        : { orderBy?: paisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pais model
   */
  readonly fields: paisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pais.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saude<T extends pais$saudeArgs<ExtArgs> = {}>(args?: Subset<T, pais$saudeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    economia<T extends pais$economiaArgs<ExtArgs> = {}>(args?: Subset<T, pais$economiaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ambiente<T extends pais$ambienteArgs<ExtArgs> = {}>(args?: Subset<T, pais$ambienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tecnologia<T extends pais$tecnologiaArgs<ExtArgs> = {}>(args?: Subset<T, pais$tecnologiaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    demografia<T extends pais$demografiaArgs<ExtArgs> = {}>(args?: Subset<T, pais$demografiaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pais model
   */
  interface paisFieldRefs {
    readonly id: FieldRef<"pais", 'String'>
    readonly nome: FieldRef<"pais", 'String'>
    readonly iso3: FieldRef<"pais", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pais findUnique
   */
  export type paisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais findUniqueOrThrow
   */
  export type paisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais findFirst
   */
  export type paisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pais.
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pais.
     */
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * pais findFirstOrThrow
   */
  export type paisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pais.
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pais.
     */
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * pais findMany
   */
  export type paisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pais.
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * pais create
   */
  export type paisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * The data needed to create a pais.
     */
    data: XOR<paisCreateInput, paisUncheckedCreateInput>
  }

  /**
   * pais createMany
   */
  export type paisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pais.
     */
    data: paisCreateManyInput | paisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pais createManyAndReturn
   */
  export type paisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * The data used to create many pais.
     */
    data: paisCreateManyInput | paisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pais update
   */
  export type paisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * The data needed to update a pais.
     */
    data: XOR<paisUpdateInput, paisUncheckedUpdateInput>
    /**
     * Choose, which pais to update.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais updateMany
   */
  export type paisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pais.
     */
    data: XOR<paisUpdateManyMutationInput, paisUncheckedUpdateManyInput>
    /**
     * Filter which pais to update
     */
    where?: paisWhereInput
    /**
     * Limit how many pais to update.
     */
    limit?: number
  }

  /**
   * pais updateManyAndReturn
   */
  export type paisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * The data used to update pais.
     */
    data: XOR<paisUpdateManyMutationInput, paisUncheckedUpdateManyInput>
    /**
     * Filter which pais to update
     */
    where?: paisWhereInput
    /**
     * Limit how many pais to update.
     */
    limit?: number
  }

  /**
   * pais upsert
   */
  export type paisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * The filter to search for the pais to update in case it exists.
     */
    where: paisWhereUniqueInput
    /**
     * In case the pais found by the `where` argument doesn't exist, create a new pais with this data.
     */
    create: XOR<paisCreateInput, paisUncheckedCreateInput>
    /**
     * In case the pais was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paisUpdateInput, paisUncheckedUpdateInput>
  }

  /**
   * pais delete
   */
  export type paisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter which pais to delete.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais deleteMany
   */
  export type paisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pais to delete
     */
    where?: paisWhereInput
    /**
     * Limit how many pais to delete.
     */
    limit?: number
  }

  /**
   * pais.saude
   */
  export type pais$saudeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    where?: saudeWhereInput
    orderBy?: saudeOrderByWithRelationInput | saudeOrderByWithRelationInput[]
    cursor?: saudeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaudeScalarFieldEnum | SaudeScalarFieldEnum[]
  }

  /**
   * pais.economia
   */
  export type pais$economiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    where?: economiaWhereInput
    orderBy?: economiaOrderByWithRelationInput | economiaOrderByWithRelationInput[]
    cursor?: economiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EconomiaScalarFieldEnum | EconomiaScalarFieldEnum[]
  }

  /**
   * pais.ambiente
   */
  export type pais$ambienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    where?: ambienteWhereInput
    orderBy?: ambienteOrderByWithRelationInput | ambienteOrderByWithRelationInput[]
    cursor?: ambienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmbienteScalarFieldEnum | AmbienteScalarFieldEnum[]
  }

  /**
   * pais.tecnologia
   */
  export type pais$tecnologiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    where?: tecnologiaWhereInput
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    cursor?: tecnologiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TecnologiaScalarFieldEnum | TecnologiaScalarFieldEnum[]
  }

  /**
   * pais.demografia
   */
  export type pais$demografiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    where?: demografiaWhereInput
    orderBy?: demografiaOrderByWithRelationInput | demografiaOrderByWithRelationInput[]
    cursor?: demografiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DemografiaScalarFieldEnum | DemografiaScalarFieldEnum[]
  }

  /**
   * pais without action
   */
  export type paisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
  }


  /**
   * Model indicador
   */

  export type AggregateIndicador = {
    _count: IndicadorCountAggregateOutputType | null
    _min: IndicadorMinAggregateOutputType | null
    _max: IndicadorMaxAggregateOutputType | null
  }

  export type IndicadorMinAggregateOutputType = {
    id: string | null
    nome: string | null
    categoria: $Enums.categoria | null
  }

  export type IndicadorMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    categoria: $Enums.categoria | null
  }

  export type IndicadorCountAggregateOutputType = {
    id: number
    nome: number
    categoria: number
    _all: number
  }


  export type IndicadorMinAggregateInputType = {
    id?: true
    nome?: true
    categoria?: true
  }

  export type IndicadorMaxAggregateInputType = {
    id?: true
    nome?: true
    categoria?: true
  }

  export type IndicadorCountAggregateInputType = {
    id?: true
    nome?: true
    categoria?: true
    _all?: true
  }

  export type IndicadorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which indicador to aggregate.
     */
    where?: indicadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of indicadors to fetch.
     */
    orderBy?: indicadorOrderByWithRelationInput | indicadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: indicadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` indicadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` indicadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned indicadors
    **/
    _count?: true | IndicadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicadorMaxAggregateInputType
  }

  export type GetIndicadorAggregateType<T extends IndicadorAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicador[P]>
      : GetScalarType<T[P], AggregateIndicador[P]>
  }




  export type indicadorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: indicadorWhereInput
    orderBy?: indicadorOrderByWithAggregationInput | indicadorOrderByWithAggregationInput[]
    by: IndicadorScalarFieldEnum[] | IndicadorScalarFieldEnum
    having?: indicadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicadorCountAggregateInputType | true
    _min?: IndicadorMinAggregateInputType
    _max?: IndicadorMaxAggregateInputType
  }

  export type IndicadorGroupByOutputType = {
    id: string
    nome: string
    categoria: $Enums.categoria
    _count: IndicadorCountAggregateOutputType | null
    _min: IndicadorMinAggregateOutputType | null
    _max: IndicadorMaxAggregateOutputType | null
  }

  type GetIndicadorGroupByPayload<T extends indicadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicadorGroupByOutputType[P]>
            : GetScalarType<T[P], IndicadorGroupByOutputType[P]>
        }
      >
    >


  export type indicadorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    categoria?: boolean
    saude?: boolean | indicador$saudeArgs<ExtArgs>
    economia?: boolean | indicador$economiaArgs<ExtArgs>
    ambiente?: boolean | indicador$ambienteArgs<ExtArgs>
    tecnologia?: boolean | indicador$tecnologiaArgs<ExtArgs>
    demografia?: boolean | indicador$demografiaArgs<ExtArgs>
    _count?: boolean | IndicadorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["indicador"]>

  export type indicadorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    categoria?: boolean
  }, ExtArgs["result"]["indicador"]>

  export type indicadorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    categoria?: boolean
  }, ExtArgs["result"]["indicador"]>

  export type indicadorSelectScalar = {
    id?: boolean
    nome?: boolean
    categoria?: boolean
  }

  export type indicadorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "categoria", ExtArgs["result"]["indicador"]>
  export type indicadorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saude?: boolean | indicador$saudeArgs<ExtArgs>
    economia?: boolean | indicador$economiaArgs<ExtArgs>
    ambiente?: boolean | indicador$ambienteArgs<ExtArgs>
    tecnologia?: boolean | indicador$tecnologiaArgs<ExtArgs>
    demografia?: boolean | indicador$demografiaArgs<ExtArgs>
    _count?: boolean | IndicadorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type indicadorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type indicadorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $indicadorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "indicador"
    objects: {
      saude: Prisma.$saudePayload<ExtArgs>[]
      economia: Prisma.$economiaPayload<ExtArgs>[]
      ambiente: Prisma.$ambientePayload<ExtArgs>[]
      tecnologia: Prisma.$tecnologiaPayload<ExtArgs>[]
      demografia: Prisma.$demografiaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      categoria: $Enums.categoria
    }, ExtArgs["result"]["indicador"]>
    composites: {}
  }

  type indicadorGetPayload<S extends boolean | null | undefined | indicadorDefaultArgs> = $Result.GetResult<Prisma.$indicadorPayload, S>

  type indicadorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<indicadorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndicadorCountAggregateInputType | true
    }

  export interface indicadorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['indicador'], meta: { name: 'indicador' } }
    /**
     * Find zero or one Indicador that matches the filter.
     * @param {indicadorFindUniqueArgs} args - Arguments to find a Indicador
     * @example
     * // Get one Indicador
     * const indicador = await prisma.indicador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends indicadorFindUniqueArgs>(args: SelectSubset<T, indicadorFindUniqueArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Indicador that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {indicadorFindUniqueOrThrowArgs} args - Arguments to find a Indicador
     * @example
     * // Get one Indicador
     * const indicador = await prisma.indicador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends indicadorFindUniqueOrThrowArgs>(args: SelectSubset<T, indicadorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Indicador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicadorFindFirstArgs} args - Arguments to find a Indicador
     * @example
     * // Get one Indicador
     * const indicador = await prisma.indicador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends indicadorFindFirstArgs>(args?: SelectSubset<T, indicadorFindFirstArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Indicador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicadorFindFirstOrThrowArgs} args - Arguments to find a Indicador
     * @example
     * // Get one Indicador
     * const indicador = await prisma.indicador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends indicadorFindFirstOrThrowArgs>(args?: SelectSubset<T, indicadorFindFirstOrThrowArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Indicadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicadorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Indicadors
     * const indicadors = await prisma.indicador.findMany()
     * 
     * // Get first 10 Indicadors
     * const indicadors = await prisma.indicador.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicadorWithIdOnly = await prisma.indicador.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends indicadorFindManyArgs>(args?: SelectSubset<T, indicadorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Indicador.
     * @param {indicadorCreateArgs} args - Arguments to create a Indicador.
     * @example
     * // Create one Indicador
     * const Indicador = await prisma.indicador.create({
     *   data: {
     *     // ... data to create a Indicador
     *   }
     * })
     * 
     */
    create<T extends indicadorCreateArgs>(args: SelectSubset<T, indicadorCreateArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Indicadors.
     * @param {indicadorCreateManyArgs} args - Arguments to create many Indicadors.
     * @example
     * // Create many Indicadors
     * const indicador = await prisma.indicador.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends indicadorCreateManyArgs>(args?: SelectSubset<T, indicadorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Indicadors and returns the data saved in the database.
     * @param {indicadorCreateManyAndReturnArgs} args - Arguments to create many Indicadors.
     * @example
     * // Create many Indicadors
     * const indicador = await prisma.indicador.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Indicadors and only return the `id`
     * const indicadorWithIdOnly = await prisma.indicador.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends indicadorCreateManyAndReturnArgs>(args?: SelectSubset<T, indicadorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Indicador.
     * @param {indicadorDeleteArgs} args - Arguments to delete one Indicador.
     * @example
     * // Delete one Indicador
     * const Indicador = await prisma.indicador.delete({
     *   where: {
     *     // ... filter to delete one Indicador
     *   }
     * })
     * 
     */
    delete<T extends indicadorDeleteArgs>(args: SelectSubset<T, indicadorDeleteArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Indicador.
     * @param {indicadorUpdateArgs} args - Arguments to update one Indicador.
     * @example
     * // Update one Indicador
     * const indicador = await prisma.indicador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends indicadorUpdateArgs>(args: SelectSubset<T, indicadorUpdateArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Indicadors.
     * @param {indicadorDeleteManyArgs} args - Arguments to filter Indicadors to delete.
     * @example
     * // Delete a few Indicadors
     * const { count } = await prisma.indicador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends indicadorDeleteManyArgs>(args?: SelectSubset<T, indicadorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Indicadors
     * const indicador = await prisma.indicador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends indicadorUpdateManyArgs>(args: SelectSubset<T, indicadorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Indicadors and returns the data updated in the database.
     * @param {indicadorUpdateManyAndReturnArgs} args - Arguments to update many Indicadors.
     * @example
     * // Update many Indicadors
     * const indicador = await prisma.indicador.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Indicadors and only return the `id`
     * const indicadorWithIdOnly = await prisma.indicador.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends indicadorUpdateManyAndReturnArgs>(args: SelectSubset<T, indicadorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Indicador.
     * @param {indicadorUpsertArgs} args - Arguments to update or create a Indicador.
     * @example
     * // Update or create a Indicador
     * const indicador = await prisma.indicador.upsert({
     *   create: {
     *     // ... data to create a Indicador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Indicador we want to update
     *   }
     * })
     */
    upsert<T extends indicadorUpsertArgs>(args: SelectSubset<T, indicadorUpsertArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Indicadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicadorCountArgs} args - Arguments to filter Indicadors to count.
     * @example
     * // Count the number of Indicadors
     * const count = await prisma.indicador.count({
     *   where: {
     *     // ... the filter for the Indicadors we want to count
     *   }
     * })
    **/
    count<T extends indicadorCountArgs>(
      args?: Subset<T, indicadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Indicador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicadorAggregateArgs>(args: Subset<T, IndicadorAggregateArgs>): Prisma.PrismaPromise<GetIndicadorAggregateType<T>>

    /**
     * Group by Indicador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {indicadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends indicadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: indicadorGroupByArgs['orderBy'] }
        : { orderBy?: indicadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, indicadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the indicador model
   */
  readonly fields: indicadorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for indicador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__indicadorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saude<T extends indicador$saudeArgs<ExtArgs> = {}>(args?: Subset<T, indicador$saudeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    economia<T extends indicador$economiaArgs<ExtArgs> = {}>(args?: Subset<T, indicador$economiaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ambiente<T extends indicador$ambienteArgs<ExtArgs> = {}>(args?: Subset<T, indicador$ambienteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tecnologia<T extends indicador$tecnologiaArgs<ExtArgs> = {}>(args?: Subset<T, indicador$tecnologiaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    demografia<T extends indicador$demografiaArgs<ExtArgs> = {}>(args?: Subset<T, indicador$demografiaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the indicador model
   */
  interface indicadorFieldRefs {
    readonly id: FieldRef<"indicador", 'String'>
    readonly nome: FieldRef<"indicador", 'String'>
    readonly categoria: FieldRef<"indicador", 'categoria'>
  }
    

  // Custom InputTypes
  /**
   * indicador findUnique
   */
  export type indicadorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
    /**
     * Filter, which indicador to fetch.
     */
    where: indicadorWhereUniqueInput
  }

  /**
   * indicador findUniqueOrThrow
   */
  export type indicadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
    /**
     * Filter, which indicador to fetch.
     */
    where: indicadorWhereUniqueInput
  }

  /**
   * indicador findFirst
   */
  export type indicadorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
    /**
     * Filter, which indicador to fetch.
     */
    where?: indicadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of indicadors to fetch.
     */
    orderBy?: indicadorOrderByWithRelationInput | indicadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for indicadors.
     */
    cursor?: indicadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` indicadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` indicadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of indicadors.
     */
    distinct?: IndicadorScalarFieldEnum | IndicadorScalarFieldEnum[]
  }

  /**
   * indicador findFirstOrThrow
   */
  export type indicadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
    /**
     * Filter, which indicador to fetch.
     */
    where?: indicadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of indicadors to fetch.
     */
    orderBy?: indicadorOrderByWithRelationInput | indicadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for indicadors.
     */
    cursor?: indicadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` indicadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` indicadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of indicadors.
     */
    distinct?: IndicadorScalarFieldEnum | IndicadorScalarFieldEnum[]
  }

  /**
   * indicador findMany
   */
  export type indicadorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
    /**
     * Filter, which indicadors to fetch.
     */
    where?: indicadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of indicadors to fetch.
     */
    orderBy?: indicadorOrderByWithRelationInput | indicadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing indicadors.
     */
    cursor?: indicadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` indicadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` indicadors.
     */
    skip?: number
    distinct?: IndicadorScalarFieldEnum | IndicadorScalarFieldEnum[]
  }

  /**
   * indicador create
   */
  export type indicadorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
    /**
     * The data needed to create a indicador.
     */
    data: XOR<indicadorCreateInput, indicadorUncheckedCreateInput>
  }

  /**
   * indicador createMany
   */
  export type indicadorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many indicadors.
     */
    data: indicadorCreateManyInput | indicadorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * indicador createManyAndReturn
   */
  export type indicadorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * The data used to create many indicadors.
     */
    data: indicadorCreateManyInput | indicadorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * indicador update
   */
  export type indicadorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
    /**
     * The data needed to update a indicador.
     */
    data: XOR<indicadorUpdateInput, indicadorUncheckedUpdateInput>
    /**
     * Choose, which indicador to update.
     */
    where: indicadorWhereUniqueInput
  }

  /**
   * indicador updateMany
   */
  export type indicadorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update indicadors.
     */
    data: XOR<indicadorUpdateManyMutationInput, indicadorUncheckedUpdateManyInput>
    /**
     * Filter which indicadors to update
     */
    where?: indicadorWhereInput
    /**
     * Limit how many indicadors to update.
     */
    limit?: number
  }

  /**
   * indicador updateManyAndReturn
   */
  export type indicadorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * The data used to update indicadors.
     */
    data: XOR<indicadorUpdateManyMutationInput, indicadorUncheckedUpdateManyInput>
    /**
     * Filter which indicadors to update
     */
    where?: indicadorWhereInput
    /**
     * Limit how many indicadors to update.
     */
    limit?: number
  }

  /**
   * indicador upsert
   */
  export type indicadorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
    /**
     * The filter to search for the indicador to update in case it exists.
     */
    where: indicadorWhereUniqueInput
    /**
     * In case the indicador found by the `where` argument doesn't exist, create a new indicador with this data.
     */
    create: XOR<indicadorCreateInput, indicadorUncheckedCreateInput>
    /**
     * In case the indicador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<indicadorUpdateInput, indicadorUncheckedUpdateInput>
  }

  /**
   * indicador delete
   */
  export type indicadorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
    /**
     * Filter which indicador to delete.
     */
    where: indicadorWhereUniqueInput
  }

  /**
   * indicador deleteMany
   */
  export type indicadorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which indicadors to delete
     */
    where?: indicadorWhereInput
    /**
     * Limit how many indicadors to delete.
     */
    limit?: number
  }

  /**
   * indicador.saude
   */
  export type indicador$saudeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    where?: saudeWhereInput
    orderBy?: saudeOrderByWithRelationInput | saudeOrderByWithRelationInput[]
    cursor?: saudeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaudeScalarFieldEnum | SaudeScalarFieldEnum[]
  }

  /**
   * indicador.economia
   */
  export type indicador$economiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    where?: economiaWhereInput
    orderBy?: economiaOrderByWithRelationInput | economiaOrderByWithRelationInput[]
    cursor?: economiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EconomiaScalarFieldEnum | EconomiaScalarFieldEnum[]
  }

  /**
   * indicador.ambiente
   */
  export type indicador$ambienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    where?: ambienteWhereInput
    orderBy?: ambienteOrderByWithRelationInput | ambienteOrderByWithRelationInput[]
    cursor?: ambienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmbienteScalarFieldEnum | AmbienteScalarFieldEnum[]
  }

  /**
   * indicador.tecnologia
   */
  export type indicador$tecnologiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    where?: tecnologiaWhereInput
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    cursor?: tecnologiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TecnologiaScalarFieldEnum | TecnologiaScalarFieldEnum[]
  }

  /**
   * indicador.demografia
   */
  export type indicador$demografiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    where?: demografiaWhereInput
    orderBy?: demografiaOrderByWithRelationInput | demografiaOrderByWithRelationInput[]
    cursor?: demografiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DemografiaScalarFieldEnum | DemografiaScalarFieldEnum[]
  }

  /**
   * indicador without action
   */
  export type indicadorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the indicador
     */
    select?: indicadorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the indicador
     */
    omit?: indicadorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: indicadorInclude<ExtArgs> | null
  }


  /**
   * Model saude
   */

  export type AggregateSaude = {
    _count: SaudeCountAggregateOutputType | null
    _avg: SaudeAvgAggregateOutputType | null
    _sum: SaudeSumAggregateOutputType | null
    _min: SaudeMinAggregateOutputType | null
    _max: SaudeMaxAggregateOutputType | null
  }

  export type SaudeAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type SaudeSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type SaudeMinAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type SaudeMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type SaudeCountAggregateOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: number
    indicador_id: number
    _all: number
  }


  export type SaudeAvgAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type SaudeSumAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type SaudeMinAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type SaudeMaxAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type SaudeCountAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
    _all?: true
  }

  export type SaudeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saude to aggregate.
     */
    where?: saudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saudes to fetch.
     */
    orderBy?: saudeOrderByWithRelationInput | saudeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned saudes
    **/
    _count?: true | SaudeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaudeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaudeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaudeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaudeMaxAggregateInputType
  }

  export type GetSaudeAggregateType<T extends SaudeAggregateArgs> = {
        [P in keyof T & keyof AggregateSaude]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaude[P]>
      : GetScalarType<T[P], AggregateSaude[P]>
  }




  export type saudeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saudeWhereInput
    orderBy?: saudeOrderByWithAggregationInput | saudeOrderByWithAggregationInput[]
    by: SaudeScalarFieldEnum[] | SaudeScalarFieldEnum
    having?: saudeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaudeCountAggregateInputType | true
    _avg?: SaudeAvgAggregateInputType
    _sum?: SaudeSumAggregateInputType
    _min?: SaudeMinAggregateInputType
    _max?: SaudeMaxAggregateInputType
  }

  export type SaudeGroupByOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
    _count: SaudeCountAggregateOutputType | null
    _avg: SaudeAvgAggregateOutputType | null
    _sum: SaudeSumAggregateOutputType | null
    _min: SaudeMinAggregateOutputType | null
    _max: SaudeMaxAggregateOutputType | null
  }

  type GetSaudeGroupByPayload<T extends saudeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaudeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaudeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaudeGroupByOutputType[P]>
            : GetScalarType<T[P], SaudeGroupByOutputType[P]>
        }
      >
    >


  export type saudeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saude"]>

  export type saudeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saude"]>

  export type saudeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saude"]>

  export type saudeSelectScalar = {
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
  }

  export type saudeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "ano" | "pais_id" | "indicador_id", ExtArgs["result"]["saude"]>
  export type saudeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type saudeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type saudeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }

  export type $saudePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "saude"
    objects: {
      pais: Prisma.$paisPayload<ExtArgs>
      indicador: Prisma.$indicadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      ano: number
      pais_id: string
      indicador_id: string
    }, ExtArgs["result"]["saude"]>
    composites: {}
  }

  type saudeGetPayload<S extends boolean | null | undefined | saudeDefaultArgs> = $Result.GetResult<Prisma.$saudePayload, S>

  type saudeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<saudeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaudeCountAggregateInputType | true
    }

  export interface saudeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['saude'], meta: { name: 'saude' } }
    /**
     * Find zero or one Saude that matches the filter.
     * @param {saudeFindUniqueArgs} args - Arguments to find a Saude
     * @example
     * // Get one Saude
     * const saude = await prisma.saude.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saudeFindUniqueArgs>(args: SelectSubset<T, saudeFindUniqueArgs<ExtArgs>>): Prisma__saudeClient<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Saude that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {saudeFindUniqueOrThrowArgs} args - Arguments to find a Saude
     * @example
     * // Get one Saude
     * const saude = await prisma.saude.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saudeFindUniqueOrThrowArgs>(args: SelectSubset<T, saudeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saudeClient<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saude that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saudeFindFirstArgs} args - Arguments to find a Saude
     * @example
     * // Get one Saude
     * const saude = await prisma.saude.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saudeFindFirstArgs>(args?: SelectSubset<T, saudeFindFirstArgs<ExtArgs>>): Prisma__saudeClient<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Saude that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saudeFindFirstOrThrowArgs} args - Arguments to find a Saude
     * @example
     * // Get one Saude
     * const saude = await prisma.saude.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saudeFindFirstOrThrowArgs>(args?: SelectSubset<T, saudeFindFirstOrThrowArgs<ExtArgs>>): Prisma__saudeClient<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Saudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saudeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saudes
     * const saudes = await prisma.saude.findMany()
     * 
     * // Get first 10 Saudes
     * const saudes = await prisma.saude.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saudeWithIdOnly = await prisma.saude.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saudeFindManyArgs>(args?: SelectSubset<T, saudeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Saude.
     * @param {saudeCreateArgs} args - Arguments to create a Saude.
     * @example
     * // Create one Saude
     * const Saude = await prisma.saude.create({
     *   data: {
     *     // ... data to create a Saude
     *   }
     * })
     * 
     */
    create<T extends saudeCreateArgs>(args: SelectSubset<T, saudeCreateArgs<ExtArgs>>): Prisma__saudeClient<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Saudes.
     * @param {saudeCreateManyArgs} args - Arguments to create many Saudes.
     * @example
     * // Create many Saudes
     * const saude = await prisma.saude.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saudeCreateManyArgs>(args?: SelectSubset<T, saudeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Saudes and returns the data saved in the database.
     * @param {saudeCreateManyAndReturnArgs} args - Arguments to create many Saudes.
     * @example
     * // Create many Saudes
     * const saude = await prisma.saude.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Saudes and only return the `id`
     * const saudeWithIdOnly = await prisma.saude.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends saudeCreateManyAndReturnArgs>(args?: SelectSubset<T, saudeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Saude.
     * @param {saudeDeleteArgs} args - Arguments to delete one Saude.
     * @example
     * // Delete one Saude
     * const Saude = await prisma.saude.delete({
     *   where: {
     *     // ... filter to delete one Saude
     *   }
     * })
     * 
     */
    delete<T extends saudeDeleteArgs>(args: SelectSubset<T, saudeDeleteArgs<ExtArgs>>): Prisma__saudeClient<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Saude.
     * @param {saudeUpdateArgs} args - Arguments to update one Saude.
     * @example
     * // Update one Saude
     * const saude = await prisma.saude.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saudeUpdateArgs>(args: SelectSubset<T, saudeUpdateArgs<ExtArgs>>): Prisma__saudeClient<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Saudes.
     * @param {saudeDeleteManyArgs} args - Arguments to filter Saudes to delete.
     * @example
     * // Delete a few Saudes
     * const { count } = await prisma.saude.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saudeDeleteManyArgs>(args?: SelectSubset<T, saudeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saudeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saudes
     * const saude = await prisma.saude.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saudeUpdateManyArgs>(args: SelectSubset<T, saudeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saudes and returns the data updated in the database.
     * @param {saudeUpdateManyAndReturnArgs} args - Arguments to update many Saudes.
     * @example
     * // Update many Saudes
     * const saude = await prisma.saude.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Saudes and only return the `id`
     * const saudeWithIdOnly = await prisma.saude.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends saudeUpdateManyAndReturnArgs>(args: SelectSubset<T, saudeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Saude.
     * @param {saudeUpsertArgs} args - Arguments to update or create a Saude.
     * @example
     * // Update or create a Saude
     * const saude = await prisma.saude.upsert({
     *   create: {
     *     // ... data to create a Saude
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Saude we want to update
     *   }
     * })
     */
    upsert<T extends saudeUpsertArgs>(args: SelectSubset<T, saudeUpsertArgs<ExtArgs>>): Prisma__saudeClient<$Result.GetResult<Prisma.$saudePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Saudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saudeCountArgs} args - Arguments to filter Saudes to count.
     * @example
     * // Count the number of Saudes
     * const count = await prisma.saude.count({
     *   where: {
     *     // ... the filter for the Saudes we want to count
     *   }
     * })
    **/
    count<T extends saudeCountArgs>(
      args?: Subset<T, saudeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaudeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Saude.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaudeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaudeAggregateArgs>(args: Subset<T, SaudeAggregateArgs>): Prisma.PrismaPromise<GetSaudeAggregateType<T>>

    /**
     * Group by Saude.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saudeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saudeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saudeGroupByArgs['orderBy'] }
        : { orderBy?: saudeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saudeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaudeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the saude model
   */
  readonly fields: saudeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for saude.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saudeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pais<T extends paisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paisDefaultArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    indicador<T extends indicadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, indicadorDefaultArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the saude model
   */
  interface saudeFieldRefs {
    readonly id: FieldRef<"saude", 'Int'>
    readonly valor: FieldRef<"saude", 'Float'>
    readonly ano: FieldRef<"saude", 'Int'>
    readonly pais_id: FieldRef<"saude", 'String'>
    readonly indicador_id: FieldRef<"saude", 'String'>
  }
    

  // Custom InputTypes
  /**
   * saude findUnique
   */
  export type saudeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    /**
     * Filter, which saude to fetch.
     */
    where: saudeWhereUniqueInput
  }

  /**
   * saude findUniqueOrThrow
   */
  export type saudeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    /**
     * Filter, which saude to fetch.
     */
    where: saudeWhereUniqueInput
  }

  /**
   * saude findFirst
   */
  export type saudeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    /**
     * Filter, which saude to fetch.
     */
    where?: saudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saudes to fetch.
     */
    orderBy?: saudeOrderByWithRelationInput | saudeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saudes.
     */
    cursor?: saudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saudes.
     */
    distinct?: SaudeScalarFieldEnum | SaudeScalarFieldEnum[]
  }

  /**
   * saude findFirstOrThrow
   */
  export type saudeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    /**
     * Filter, which saude to fetch.
     */
    where?: saudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saudes to fetch.
     */
    orderBy?: saudeOrderByWithRelationInput | saudeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saudes.
     */
    cursor?: saudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saudes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saudes.
     */
    distinct?: SaudeScalarFieldEnum | SaudeScalarFieldEnum[]
  }

  /**
   * saude findMany
   */
  export type saudeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    /**
     * Filter, which saudes to fetch.
     */
    where?: saudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saudes to fetch.
     */
    orderBy?: saudeOrderByWithRelationInput | saudeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing saudes.
     */
    cursor?: saudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saudes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saudes.
     */
    skip?: number
    distinct?: SaudeScalarFieldEnum | SaudeScalarFieldEnum[]
  }

  /**
   * saude create
   */
  export type saudeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    /**
     * The data needed to create a saude.
     */
    data: XOR<saudeCreateInput, saudeUncheckedCreateInput>
  }

  /**
   * saude createMany
   */
  export type saudeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many saudes.
     */
    data: saudeCreateManyInput | saudeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saude createManyAndReturn
   */
  export type saudeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * The data used to create many saudes.
     */
    data: saudeCreateManyInput | saudeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * saude update
   */
  export type saudeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    /**
     * The data needed to update a saude.
     */
    data: XOR<saudeUpdateInput, saudeUncheckedUpdateInput>
    /**
     * Choose, which saude to update.
     */
    where: saudeWhereUniqueInput
  }

  /**
   * saude updateMany
   */
  export type saudeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update saudes.
     */
    data: XOR<saudeUpdateManyMutationInput, saudeUncheckedUpdateManyInput>
    /**
     * Filter which saudes to update
     */
    where?: saudeWhereInput
    /**
     * Limit how many saudes to update.
     */
    limit?: number
  }

  /**
   * saude updateManyAndReturn
   */
  export type saudeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * The data used to update saudes.
     */
    data: XOR<saudeUpdateManyMutationInput, saudeUncheckedUpdateManyInput>
    /**
     * Filter which saudes to update
     */
    where?: saudeWhereInput
    /**
     * Limit how many saudes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * saude upsert
   */
  export type saudeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    /**
     * The filter to search for the saude to update in case it exists.
     */
    where: saudeWhereUniqueInput
    /**
     * In case the saude found by the `where` argument doesn't exist, create a new saude with this data.
     */
    create: XOR<saudeCreateInput, saudeUncheckedCreateInput>
    /**
     * In case the saude was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saudeUpdateInput, saudeUncheckedUpdateInput>
  }

  /**
   * saude delete
   */
  export type saudeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
    /**
     * Filter which saude to delete.
     */
    where: saudeWhereUniqueInput
  }

  /**
   * saude deleteMany
   */
  export type saudeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saudes to delete
     */
    where?: saudeWhereInput
    /**
     * Limit how many saudes to delete.
     */
    limit?: number
  }

  /**
   * saude without action
   */
  export type saudeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saude
     */
    select?: saudeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the saude
     */
    omit?: saudeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saudeInclude<ExtArgs> | null
  }


  /**
   * Model economia
   */

  export type AggregateEconomia = {
    _count: EconomiaCountAggregateOutputType | null
    _avg: EconomiaAvgAggregateOutputType | null
    _sum: EconomiaSumAggregateOutputType | null
    _min: EconomiaMinAggregateOutputType | null
    _max: EconomiaMaxAggregateOutputType | null
  }

  export type EconomiaAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type EconomiaSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type EconomiaMinAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type EconomiaMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type EconomiaCountAggregateOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: number
    indicador_id: number
    _all: number
  }


  export type EconomiaAvgAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type EconomiaSumAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type EconomiaMinAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type EconomiaMaxAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type EconomiaCountAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
    _all?: true
  }

  export type EconomiaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which economia to aggregate.
     */
    where?: economiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of economias to fetch.
     */
    orderBy?: economiaOrderByWithRelationInput | economiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: economiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` economias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` economias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned economias
    **/
    _count?: true | EconomiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EconomiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EconomiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EconomiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EconomiaMaxAggregateInputType
  }

  export type GetEconomiaAggregateType<T extends EconomiaAggregateArgs> = {
        [P in keyof T & keyof AggregateEconomia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEconomia[P]>
      : GetScalarType<T[P], AggregateEconomia[P]>
  }




  export type economiaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: economiaWhereInput
    orderBy?: economiaOrderByWithAggregationInput | economiaOrderByWithAggregationInput[]
    by: EconomiaScalarFieldEnum[] | EconomiaScalarFieldEnum
    having?: economiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EconomiaCountAggregateInputType | true
    _avg?: EconomiaAvgAggregateInputType
    _sum?: EconomiaSumAggregateInputType
    _min?: EconomiaMinAggregateInputType
    _max?: EconomiaMaxAggregateInputType
  }

  export type EconomiaGroupByOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
    _count: EconomiaCountAggregateOutputType | null
    _avg: EconomiaAvgAggregateOutputType | null
    _sum: EconomiaSumAggregateOutputType | null
    _min: EconomiaMinAggregateOutputType | null
    _max: EconomiaMaxAggregateOutputType | null
  }

  type GetEconomiaGroupByPayload<T extends economiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EconomiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EconomiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EconomiaGroupByOutputType[P]>
            : GetScalarType<T[P], EconomiaGroupByOutputType[P]>
        }
      >
    >


  export type economiaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["economia"]>

  export type economiaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["economia"]>

  export type economiaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["economia"]>

  export type economiaSelectScalar = {
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
  }

  export type economiaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "ano" | "pais_id" | "indicador_id", ExtArgs["result"]["economia"]>
  export type economiaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type economiaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type economiaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }

  export type $economiaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "economia"
    objects: {
      pais: Prisma.$paisPayload<ExtArgs>
      indicador: Prisma.$indicadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      ano: number
      pais_id: string
      indicador_id: string
    }, ExtArgs["result"]["economia"]>
    composites: {}
  }

  type economiaGetPayload<S extends boolean | null | undefined | economiaDefaultArgs> = $Result.GetResult<Prisma.$economiaPayload, S>

  type economiaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<economiaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EconomiaCountAggregateInputType | true
    }

  export interface economiaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['economia'], meta: { name: 'economia' } }
    /**
     * Find zero or one Economia that matches the filter.
     * @param {economiaFindUniqueArgs} args - Arguments to find a Economia
     * @example
     * // Get one Economia
     * const economia = await prisma.economia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends economiaFindUniqueArgs>(args: SelectSubset<T, economiaFindUniqueArgs<ExtArgs>>): Prisma__economiaClient<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Economia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {economiaFindUniqueOrThrowArgs} args - Arguments to find a Economia
     * @example
     * // Get one Economia
     * const economia = await prisma.economia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends economiaFindUniqueOrThrowArgs>(args: SelectSubset<T, economiaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__economiaClient<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Economia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {economiaFindFirstArgs} args - Arguments to find a Economia
     * @example
     * // Get one Economia
     * const economia = await prisma.economia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends economiaFindFirstArgs>(args?: SelectSubset<T, economiaFindFirstArgs<ExtArgs>>): Prisma__economiaClient<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Economia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {economiaFindFirstOrThrowArgs} args - Arguments to find a Economia
     * @example
     * // Get one Economia
     * const economia = await prisma.economia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends economiaFindFirstOrThrowArgs>(args?: SelectSubset<T, economiaFindFirstOrThrowArgs<ExtArgs>>): Prisma__economiaClient<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Economias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {economiaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Economias
     * const economias = await prisma.economia.findMany()
     * 
     * // Get first 10 Economias
     * const economias = await prisma.economia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const economiaWithIdOnly = await prisma.economia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends economiaFindManyArgs>(args?: SelectSubset<T, economiaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Economia.
     * @param {economiaCreateArgs} args - Arguments to create a Economia.
     * @example
     * // Create one Economia
     * const Economia = await prisma.economia.create({
     *   data: {
     *     // ... data to create a Economia
     *   }
     * })
     * 
     */
    create<T extends economiaCreateArgs>(args: SelectSubset<T, economiaCreateArgs<ExtArgs>>): Prisma__economiaClient<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Economias.
     * @param {economiaCreateManyArgs} args - Arguments to create many Economias.
     * @example
     * // Create many Economias
     * const economia = await prisma.economia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends economiaCreateManyArgs>(args?: SelectSubset<T, economiaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Economias and returns the data saved in the database.
     * @param {economiaCreateManyAndReturnArgs} args - Arguments to create many Economias.
     * @example
     * // Create many Economias
     * const economia = await prisma.economia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Economias and only return the `id`
     * const economiaWithIdOnly = await prisma.economia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends economiaCreateManyAndReturnArgs>(args?: SelectSubset<T, economiaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Economia.
     * @param {economiaDeleteArgs} args - Arguments to delete one Economia.
     * @example
     * // Delete one Economia
     * const Economia = await prisma.economia.delete({
     *   where: {
     *     // ... filter to delete one Economia
     *   }
     * })
     * 
     */
    delete<T extends economiaDeleteArgs>(args: SelectSubset<T, economiaDeleteArgs<ExtArgs>>): Prisma__economiaClient<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Economia.
     * @param {economiaUpdateArgs} args - Arguments to update one Economia.
     * @example
     * // Update one Economia
     * const economia = await prisma.economia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends economiaUpdateArgs>(args: SelectSubset<T, economiaUpdateArgs<ExtArgs>>): Prisma__economiaClient<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Economias.
     * @param {economiaDeleteManyArgs} args - Arguments to filter Economias to delete.
     * @example
     * // Delete a few Economias
     * const { count } = await prisma.economia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends economiaDeleteManyArgs>(args?: SelectSubset<T, economiaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Economias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {economiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Economias
     * const economia = await prisma.economia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends economiaUpdateManyArgs>(args: SelectSubset<T, economiaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Economias and returns the data updated in the database.
     * @param {economiaUpdateManyAndReturnArgs} args - Arguments to update many Economias.
     * @example
     * // Update many Economias
     * const economia = await prisma.economia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Economias and only return the `id`
     * const economiaWithIdOnly = await prisma.economia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends economiaUpdateManyAndReturnArgs>(args: SelectSubset<T, economiaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Economia.
     * @param {economiaUpsertArgs} args - Arguments to update or create a Economia.
     * @example
     * // Update or create a Economia
     * const economia = await prisma.economia.upsert({
     *   create: {
     *     // ... data to create a Economia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Economia we want to update
     *   }
     * })
     */
    upsert<T extends economiaUpsertArgs>(args: SelectSubset<T, economiaUpsertArgs<ExtArgs>>): Prisma__economiaClient<$Result.GetResult<Prisma.$economiaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Economias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {economiaCountArgs} args - Arguments to filter Economias to count.
     * @example
     * // Count the number of Economias
     * const count = await prisma.economia.count({
     *   where: {
     *     // ... the filter for the Economias we want to count
     *   }
     * })
    **/
    count<T extends economiaCountArgs>(
      args?: Subset<T, economiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EconomiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Economia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EconomiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EconomiaAggregateArgs>(args: Subset<T, EconomiaAggregateArgs>): Prisma.PrismaPromise<GetEconomiaAggregateType<T>>

    /**
     * Group by Economia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {economiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends economiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: economiaGroupByArgs['orderBy'] }
        : { orderBy?: economiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, economiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEconomiaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the economia model
   */
  readonly fields: economiaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for economia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__economiaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pais<T extends paisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paisDefaultArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    indicador<T extends indicadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, indicadorDefaultArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the economia model
   */
  interface economiaFieldRefs {
    readonly id: FieldRef<"economia", 'Int'>
    readonly valor: FieldRef<"economia", 'Float'>
    readonly ano: FieldRef<"economia", 'Int'>
    readonly pais_id: FieldRef<"economia", 'String'>
    readonly indicador_id: FieldRef<"economia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * economia findUnique
   */
  export type economiaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    /**
     * Filter, which economia to fetch.
     */
    where: economiaWhereUniqueInput
  }

  /**
   * economia findUniqueOrThrow
   */
  export type economiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    /**
     * Filter, which economia to fetch.
     */
    where: economiaWhereUniqueInput
  }

  /**
   * economia findFirst
   */
  export type economiaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    /**
     * Filter, which economia to fetch.
     */
    where?: economiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of economias to fetch.
     */
    orderBy?: economiaOrderByWithRelationInput | economiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for economias.
     */
    cursor?: economiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` economias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` economias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of economias.
     */
    distinct?: EconomiaScalarFieldEnum | EconomiaScalarFieldEnum[]
  }

  /**
   * economia findFirstOrThrow
   */
  export type economiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    /**
     * Filter, which economia to fetch.
     */
    where?: economiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of economias to fetch.
     */
    orderBy?: economiaOrderByWithRelationInput | economiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for economias.
     */
    cursor?: economiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` economias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` economias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of economias.
     */
    distinct?: EconomiaScalarFieldEnum | EconomiaScalarFieldEnum[]
  }

  /**
   * economia findMany
   */
  export type economiaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    /**
     * Filter, which economias to fetch.
     */
    where?: economiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of economias to fetch.
     */
    orderBy?: economiaOrderByWithRelationInput | economiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing economias.
     */
    cursor?: economiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` economias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` economias.
     */
    skip?: number
    distinct?: EconomiaScalarFieldEnum | EconomiaScalarFieldEnum[]
  }

  /**
   * economia create
   */
  export type economiaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    /**
     * The data needed to create a economia.
     */
    data: XOR<economiaCreateInput, economiaUncheckedCreateInput>
  }

  /**
   * economia createMany
   */
  export type economiaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many economias.
     */
    data: economiaCreateManyInput | economiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * economia createManyAndReturn
   */
  export type economiaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * The data used to create many economias.
     */
    data: economiaCreateManyInput | economiaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * economia update
   */
  export type economiaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    /**
     * The data needed to update a economia.
     */
    data: XOR<economiaUpdateInput, economiaUncheckedUpdateInput>
    /**
     * Choose, which economia to update.
     */
    where: economiaWhereUniqueInput
  }

  /**
   * economia updateMany
   */
  export type economiaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update economias.
     */
    data: XOR<economiaUpdateManyMutationInput, economiaUncheckedUpdateManyInput>
    /**
     * Filter which economias to update
     */
    where?: economiaWhereInput
    /**
     * Limit how many economias to update.
     */
    limit?: number
  }

  /**
   * economia updateManyAndReturn
   */
  export type economiaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * The data used to update economias.
     */
    data: XOR<economiaUpdateManyMutationInput, economiaUncheckedUpdateManyInput>
    /**
     * Filter which economias to update
     */
    where?: economiaWhereInput
    /**
     * Limit how many economias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * economia upsert
   */
  export type economiaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    /**
     * The filter to search for the economia to update in case it exists.
     */
    where: economiaWhereUniqueInput
    /**
     * In case the economia found by the `where` argument doesn't exist, create a new economia with this data.
     */
    create: XOR<economiaCreateInput, economiaUncheckedCreateInput>
    /**
     * In case the economia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<economiaUpdateInput, economiaUncheckedUpdateInput>
  }

  /**
   * economia delete
   */
  export type economiaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
    /**
     * Filter which economia to delete.
     */
    where: economiaWhereUniqueInput
  }

  /**
   * economia deleteMany
   */
  export type economiaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which economias to delete
     */
    where?: economiaWhereInput
    /**
     * Limit how many economias to delete.
     */
    limit?: number
  }

  /**
   * economia without action
   */
  export type economiaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the economia
     */
    select?: economiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the economia
     */
    omit?: economiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: economiaInclude<ExtArgs> | null
  }


  /**
   * Model ambiente
   */

  export type AggregateAmbiente = {
    _count: AmbienteCountAggregateOutputType | null
    _avg: AmbienteAvgAggregateOutputType | null
    _sum: AmbienteSumAggregateOutputType | null
    _min: AmbienteMinAggregateOutputType | null
    _max: AmbienteMaxAggregateOutputType | null
  }

  export type AmbienteAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type AmbienteSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type AmbienteMinAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type AmbienteMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type AmbienteCountAggregateOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: number
    indicador_id: number
    _all: number
  }


  export type AmbienteAvgAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type AmbienteSumAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type AmbienteMinAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type AmbienteMaxAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type AmbienteCountAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
    _all?: true
  }

  export type AmbienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ambiente to aggregate.
     */
    where?: ambienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ambientes to fetch.
     */
    orderBy?: ambienteOrderByWithRelationInput | ambienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ambienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ambientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ambientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ambientes
    **/
    _count?: true | AmbienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmbienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmbienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmbienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmbienteMaxAggregateInputType
  }

  export type GetAmbienteAggregateType<T extends AmbienteAggregateArgs> = {
        [P in keyof T & keyof AggregateAmbiente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmbiente[P]>
      : GetScalarType<T[P], AggregateAmbiente[P]>
  }




  export type ambienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ambienteWhereInput
    orderBy?: ambienteOrderByWithAggregationInput | ambienteOrderByWithAggregationInput[]
    by: AmbienteScalarFieldEnum[] | AmbienteScalarFieldEnum
    having?: ambienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmbienteCountAggregateInputType | true
    _avg?: AmbienteAvgAggregateInputType
    _sum?: AmbienteSumAggregateInputType
    _min?: AmbienteMinAggregateInputType
    _max?: AmbienteMaxAggregateInputType
  }

  export type AmbienteGroupByOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
    _count: AmbienteCountAggregateOutputType | null
    _avg: AmbienteAvgAggregateOutputType | null
    _sum: AmbienteSumAggregateOutputType | null
    _min: AmbienteMinAggregateOutputType | null
    _max: AmbienteMaxAggregateOutputType | null
  }

  type GetAmbienteGroupByPayload<T extends ambienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmbienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmbienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmbienteGroupByOutputType[P]>
            : GetScalarType<T[P], AmbienteGroupByOutputType[P]>
        }
      >
    >


  export type ambienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambiente"]>

  export type ambienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambiente"]>

  export type ambienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambiente"]>

  export type ambienteSelectScalar = {
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
  }

  export type ambienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "ano" | "pais_id" | "indicador_id", ExtArgs["result"]["ambiente"]>
  export type ambienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type ambienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type ambienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }

  export type $ambientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ambiente"
    objects: {
      pais: Prisma.$paisPayload<ExtArgs>
      indicador: Prisma.$indicadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      ano: number
      pais_id: string
      indicador_id: string
    }, ExtArgs["result"]["ambiente"]>
    composites: {}
  }

  type ambienteGetPayload<S extends boolean | null | undefined | ambienteDefaultArgs> = $Result.GetResult<Prisma.$ambientePayload, S>

  type ambienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ambienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmbienteCountAggregateInputType | true
    }

  export interface ambienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ambiente'], meta: { name: 'ambiente' } }
    /**
     * Find zero or one Ambiente that matches the filter.
     * @param {ambienteFindUniqueArgs} args - Arguments to find a Ambiente
     * @example
     * // Get one Ambiente
     * const ambiente = await prisma.ambiente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ambienteFindUniqueArgs>(args: SelectSubset<T, ambienteFindUniqueArgs<ExtArgs>>): Prisma__ambienteClient<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ambiente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ambienteFindUniqueOrThrowArgs} args - Arguments to find a Ambiente
     * @example
     * // Get one Ambiente
     * const ambiente = await prisma.ambiente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ambienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ambienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ambienteClient<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ambiente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ambienteFindFirstArgs} args - Arguments to find a Ambiente
     * @example
     * // Get one Ambiente
     * const ambiente = await prisma.ambiente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ambienteFindFirstArgs>(args?: SelectSubset<T, ambienteFindFirstArgs<ExtArgs>>): Prisma__ambienteClient<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ambiente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ambienteFindFirstOrThrowArgs} args - Arguments to find a Ambiente
     * @example
     * // Get one Ambiente
     * const ambiente = await prisma.ambiente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ambienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ambienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ambienteClient<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ambientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ambienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ambientes
     * const ambientes = await prisma.ambiente.findMany()
     * 
     * // Get first 10 Ambientes
     * const ambientes = await prisma.ambiente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ambienteWithIdOnly = await prisma.ambiente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ambienteFindManyArgs>(args?: SelectSubset<T, ambienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ambiente.
     * @param {ambienteCreateArgs} args - Arguments to create a Ambiente.
     * @example
     * // Create one Ambiente
     * const Ambiente = await prisma.ambiente.create({
     *   data: {
     *     // ... data to create a Ambiente
     *   }
     * })
     * 
     */
    create<T extends ambienteCreateArgs>(args: SelectSubset<T, ambienteCreateArgs<ExtArgs>>): Prisma__ambienteClient<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ambientes.
     * @param {ambienteCreateManyArgs} args - Arguments to create many Ambientes.
     * @example
     * // Create many Ambientes
     * const ambiente = await prisma.ambiente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ambienteCreateManyArgs>(args?: SelectSubset<T, ambienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ambientes and returns the data saved in the database.
     * @param {ambienteCreateManyAndReturnArgs} args - Arguments to create many Ambientes.
     * @example
     * // Create many Ambientes
     * const ambiente = await prisma.ambiente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ambientes and only return the `id`
     * const ambienteWithIdOnly = await prisma.ambiente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ambienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ambienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ambiente.
     * @param {ambienteDeleteArgs} args - Arguments to delete one Ambiente.
     * @example
     * // Delete one Ambiente
     * const Ambiente = await prisma.ambiente.delete({
     *   where: {
     *     // ... filter to delete one Ambiente
     *   }
     * })
     * 
     */
    delete<T extends ambienteDeleteArgs>(args: SelectSubset<T, ambienteDeleteArgs<ExtArgs>>): Prisma__ambienteClient<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ambiente.
     * @param {ambienteUpdateArgs} args - Arguments to update one Ambiente.
     * @example
     * // Update one Ambiente
     * const ambiente = await prisma.ambiente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ambienteUpdateArgs>(args: SelectSubset<T, ambienteUpdateArgs<ExtArgs>>): Prisma__ambienteClient<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ambientes.
     * @param {ambienteDeleteManyArgs} args - Arguments to filter Ambientes to delete.
     * @example
     * // Delete a few Ambientes
     * const { count } = await prisma.ambiente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ambienteDeleteManyArgs>(args?: SelectSubset<T, ambienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ambientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ambienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ambientes
     * const ambiente = await prisma.ambiente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ambienteUpdateManyArgs>(args: SelectSubset<T, ambienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ambientes and returns the data updated in the database.
     * @param {ambienteUpdateManyAndReturnArgs} args - Arguments to update many Ambientes.
     * @example
     * // Update many Ambientes
     * const ambiente = await prisma.ambiente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ambientes and only return the `id`
     * const ambienteWithIdOnly = await prisma.ambiente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ambienteUpdateManyAndReturnArgs>(args: SelectSubset<T, ambienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ambiente.
     * @param {ambienteUpsertArgs} args - Arguments to update or create a Ambiente.
     * @example
     * // Update or create a Ambiente
     * const ambiente = await prisma.ambiente.upsert({
     *   create: {
     *     // ... data to create a Ambiente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ambiente we want to update
     *   }
     * })
     */
    upsert<T extends ambienteUpsertArgs>(args: SelectSubset<T, ambienteUpsertArgs<ExtArgs>>): Prisma__ambienteClient<$Result.GetResult<Prisma.$ambientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ambientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ambienteCountArgs} args - Arguments to filter Ambientes to count.
     * @example
     * // Count the number of Ambientes
     * const count = await prisma.ambiente.count({
     *   where: {
     *     // ... the filter for the Ambientes we want to count
     *   }
     * })
    **/
    count<T extends ambienteCountArgs>(
      args?: Subset<T, ambienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmbienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ambiente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmbienteAggregateArgs>(args: Subset<T, AmbienteAggregateArgs>): Prisma.PrismaPromise<GetAmbienteAggregateType<T>>

    /**
     * Group by Ambiente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ambienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ambienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ambienteGroupByArgs['orderBy'] }
        : { orderBy?: ambienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ambienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmbienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ambiente model
   */
  readonly fields: ambienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ambiente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ambienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pais<T extends paisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paisDefaultArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    indicador<T extends indicadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, indicadorDefaultArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ambiente model
   */
  interface ambienteFieldRefs {
    readonly id: FieldRef<"ambiente", 'Int'>
    readonly valor: FieldRef<"ambiente", 'Float'>
    readonly ano: FieldRef<"ambiente", 'Int'>
    readonly pais_id: FieldRef<"ambiente", 'String'>
    readonly indicador_id: FieldRef<"ambiente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ambiente findUnique
   */
  export type ambienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    /**
     * Filter, which ambiente to fetch.
     */
    where: ambienteWhereUniqueInput
  }

  /**
   * ambiente findUniqueOrThrow
   */
  export type ambienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    /**
     * Filter, which ambiente to fetch.
     */
    where: ambienteWhereUniqueInput
  }

  /**
   * ambiente findFirst
   */
  export type ambienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    /**
     * Filter, which ambiente to fetch.
     */
    where?: ambienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ambientes to fetch.
     */
    orderBy?: ambienteOrderByWithRelationInput | ambienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ambientes.
     */
    cursor?: ambienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ambientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ambientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ambientes.
     */
    distinct?: AmbienteScalarFieldEnum | AmbienteScalarFieldEnum[]
  }

  /**
   * ambiente findFirstOrThrow
   */
  export type ambienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    /**
     * Filter, which ambiente to fetch.
     */
    where?: ambienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ambientes to fetch.
     */
    orderBy?: ambienteOrderByWithRelationInput | ambienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ambientes.
     */
    cursor?: ambienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ambientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ambientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ambientes.
     */
    distinct?: AmbienteScalarFieldEnum | AmbienteScalarFieldEnum[]
  }

  /**
   * ambiente findMany
   */
  export type ambienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    /**
     * Filter, which ambientes to fetch.
     */
    where?: ambienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ambientes to fetch.
     */
    orderBy?: ambienteOrderByWithRelationInput | ambienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ambientes.
     */
    cursor?: ambienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ambientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ambientes.
     */
    skip?: number
    distinct?: AmbienteScalarFieldEnum | AmbienteScalarFieldEnum[]
  }

  /**
   * ambiente create
   */
  export type ambienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    /**
     * The data needed to create a ambiente.
     */
    data: XOR<ambienteCreateInput, ambienteUncheckedCreateInput>
  }

  /**
   * ambiente createMany
   */
  export type ambienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ambientes.
     */
    data: ambienteCreateManyInput | ambienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ambiente createManyAndReturn
   */
  export type ambienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * The data used to create many ambientes.
     */
    data: ambienteCreateManyInput | ambienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ambiente update
   */
  export type ambienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    /**
     * The data needed to update a ambiente.
     */
    data: XOR<ambienteUpdateInput, ambienteUncheckedUpdateInput>
    /**
     * Choose, which ambiente to update.
     */
    where: ambienteWhereUniqueInput
  }

  /**
   * ambiente updateMany
   */
  export type ambienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ambientes.
     */
    data: XOR<ambienteUpdateManyMutationInput, ambienteUncheckedUpdateManyInput>
    /**
     * Filter which ambientes to update
     */
    where?: ambienteWhereInput
    /**
     * Limit how many ambientes to update.
     */
    limit?: number
  }

  /**
   * ambiente updateManyAndReturn
   */
  export type ambienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * The data used to update ambientes.
     */
    data: XOR<ambienteUpdateManyMutationInput, ambienteUncheckedUpdateManyInput>
    /**
     * Filter which ambientes to update
     */
    where?: ambienteWhereInput
    /**
     * Limit how many ambientes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ambiente upsert
   */
  export type ambienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    /**
     * The filter to search for the ambiente to update in case it exists.
     */
    where: ambienteWhereUniqueInput
    /**
     * In case the ambiente found by the `where` argument doesn't exist, create a new ambiente with this data.
     */
    create: XOR<ambienteCreateInput, ambienteUncheckedCreateInput>
    /**
     * In case the ambiente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ambienteUpdateInput, ambienteUncheckedUpdateInput>
  }

  /**
   * ambiente delete
   */
  export type ambienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
    /**
     * Filter which ambiente to delete.
     */
    where: ambienteWhereUniqueInput
  }

  /**
   * ambiente deleteMany
   */
  export type ambienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ambientes to delete
     */
    where?: ambienteWhereInput
    /**
     * Limit how many ambientes to delete.
     */
    limit?: number
  }

  /**
   * ambiente without action
   */
  export type ambienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ambiente
     */
    select?: ambienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ambiente
     */
    omit?: ambienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ambienteInclude<ExtArgs> | null
  }


  /**
   * Model tecnologia
   */

  export type AggregateTecnologia = {
    _count: TecnologiaCountAggregateOutputType | null
    _avg: TecnologiaAvgAggregateOutputType | null
    _sum: TecnologiaSumAggregateOutputType | null
    _min: TecnologiaMinAggregateOutputType | null
    _max: TecnologiaMaxAggregateOutputType | null
  }

  export type TecnologiaAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type TecnologiaSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type TecnologiaMinAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type TecnologiaMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type TecnologiaCountAggregateOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: number
    indicador_id: number
    _all: number
  }


  export type TecnologiaAvgAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type TecnologiaSumAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type TecnologiaMinAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type TecnologiaMaxAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type TecnologiaCountAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
    _all?: true
  }

  export type TecnologiaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tecnologia to aggregate.
     */
    where?: tecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologias to fetch.
     */
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tecnologias
    **/
    _count?: true | TecnologiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TecnologiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TecnologiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TecnologiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TecnologiaMaxAggregateInputType
  }

  export type GetTecnologiaAggregateType<T extends TecnologiaAggregateArgs> = {
        [P in keyof T & keyof AggregateTecnologia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTecnologia[P]>
      : GetScalarType<T[P], AggregateTecnologia[P]>
  }




  export type tecnologiaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tecnologiaWhereInput
    orderBy?: tecnologiaOrderByWithAggregationInput | tecnologiaOrderByWithAggregationInput[]
    by: TecnologiaScalarFieldEnum[] | TecnologiaScalarFieldEnum
    having?: tecnologiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TecnologiaCountAggregateInputType | true
    _avg?: TecnologiaAvgAggregateInputType
    _sum?: TecnologiaSumAggregateInputType
    _min?: TecnologiaMinAggregateInputType
    _max?: TecnologiaMaxAggregateInputType
  }

  export type TecnologiaGroupByOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
    _count: TecnologiaCountAggregateOutputType | null
    _avg: TecnologiaAvgAggregateOutputType | null
    _sum: TecnologiaSumAggregateOutputType | null
    _min: TecnologiaMinAggregateOutputType | null
    _max: TecnologiaMaxAggregateOutputType | null
  }

  type GetTecnologiaGroupByPayload<T extends tecnologiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TecnologiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TecnologiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TecnologiaGroupByOutputType[P]>
            : GetScalarType<T[P], TecnologiaGroupByOutputType[P]>
        }
      >
    >


  export type tecnologiaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tecnologia"]>

  export type tecnologiaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tecnologia"]>

  export type tecnologiaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tecnologia"]>

  export type tecnologiaSelectScalar = {
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
  }

  export type tecnologiaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "ano" | "pais_id" | "indicador_id", ExtArgs["result"]["tecnologia"]>
  export type tecnologiaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type tecnologiaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type tecnologiaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }

  export type $tecnologiaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tecnologia"
    objects: {
      pais: Prisma.$paisPayload<ExtArgs>
      indicador: Prisma.$indicadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      ano: number
      pais_id: string
      indicador_id: string
    }, ExtArgs["result"]["tecnologia"]>
    composites: {}
  }

  type tecnologiaGetPayload<S extends boolean | null | undefined | tecnologiaDefaultArgs> = $Result.GetResult<Prisma.$tecnologiaPayload, S>

  type tecnologiaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tecnologiaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TecnologiaCountAggregateInputType | true
    }

  export interface tecnologiaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tecnologia'], meta: { name: 'tecnologia' } }
    /**
     * Find zero or one Tecnologia that matches the filter.
     * @param {tecnologiaFindUniqueArgs} args - Arguments to find a Tecnologia
     * @example
     * // Get one Tecnologia
     * const tecnologia = await prisma.tecnologia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tecnologiaFindUniqueArgs>(args: SelectSubset<T, tecnologiaFindUniqueArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tecnologia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tecnologiaFindUniqueOrThrowArgs} args - Arguments to find a Tecnologia
     * @example
     * // Get one Tecnologia
     * const tecnologia = await prisma.tecnologia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tecnologiaFindUniqueOrThrowArgs>(args: SelectSubset<T, tecnologiaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tecnologia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaFindFirstArgs} args - Arguments to find a Tecnologia
     * @example
     * // Get one Tecnologia
     * const tecnologia = await prisma.tecnologia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tecnologiaFindFirstArgs>(args?: SelectSubset<T, tecnologiaFindFirstArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tecnologia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaFindFirstOrThrowArgs} args - Arguments to find a Tecnologia
     * @example
     * // Get one Tecnologia
     * const tecnologia = await prisma.tecnologia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tecnologiaFindFirstOrThrowArgs>(args?: SelectSubset<T, tecnologiaFindFirstOrThrowArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tecnologias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tecnologias
     * const tecnologias = await prisma.tecnologia.findMany()
     * 
     * // Get first 10 Tecnologias
     * const tecnologias = await prisma.tecnologia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tecnologiaWithIdOnly = await prisma.tecnologia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tecnologiaFindManyArgs>(args?: SelectSubset<T, tecnologiaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tecnologia.
     * @param {tecnologiaCreateArgs} args - Arguments to create a Tecnologia.
     * @example
     * // Create one Tecnologia
     * const Tecnologia = await prisma.tecnologia.create({
     *   data: {
     *     // ... data to create a Tecnologia
     *   }
     * })
     * 
     */
    create<T extends tecnologiaCreateArgs>(args: SelectSubset<T, tecnologiaCreateArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tecnologias.
     * @param {tecnologiaCreateManyArgs} args - Arguments to create many Tecnologias.
     * @example
     * // Create many Tecnologias
     * const tecnologia = await prisma.tecnologia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tecnologiaCreateManyArgs>(args?: SelectSubset<T, tecnologiaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tecnologias and returns the data saved in the database.
     * @param {tecnologiaCreateManyAndReturnArgs} args - Arguments to create many Tecnologias.
     * @example
     * // Create many Tecnologias
     * const tecnologia = await prisma.tecnologia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tecnologias and only return the `id`
     * const tecnologiaWithIdOnly = await prisma.tecnologia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tecnologiaCreateManyAndReturnArgs>(args?: SelectSubset<T, tecnologiaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tecnologia.
     * @param {tecnologiaDeleteArgs} args - Arguments to delete one Tecnologia.
     * @example
     * // Delete one Tecnologia
     * const Tecnologia = await prisma.tecnologia.delete({
     *   where: {
     *     // ... filter to delete one Tecnologia
     *   }
     * })
     * 
     */
    delete<T extends tecnologiaDeleteArgs>(args: SelectSubset<T, tecnologiaDeleteArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tecnologia.
     * @param {tecnologiaUpdateArgs} args - Arguments to update one Tecnologia.
     * @example
     * // Update one Tecnologia
     * const tecnologia = await prisma.tecnologia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tecnologiaUpdateArgs>(args: SelectSubset<T, tecnologiaUpdateArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tecnologias.
     * @param {tecnologiaDeleteManyArgs} args - Arguments to filter Tecnologias to delete.
     * @example
     * // Delete a few Tecnologias
     * const { count } = await prisma.tecnologia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tecnologiaDeleteManyArgs>(args?: SelectSubset<T, tecnologiaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tecnologias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tecnologias
     * const tecnologia = await prisma.tecnologia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tecnologiaUpdateManyArgs>(args: SelectSubset<T, tecnologiaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tecnologias and returns the data updated in the database.
     * @param {tecnologiaUpdateManyAndReturnArgs} args - Arguments to update many Tecnologias.
     * @example
     * // Update many Tecnologias
     * const tecnologia = await prisma.tecnologia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tecnologias and only return the `id`
     * const tecnologiaWithIdOnly = await prisma.tecnologia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tecnologiaUpdateManyAndReturnArgs>(args: SelectSubset<T, tecnologiaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tecnologia.
     * @param {tecnologiaUpsertArgs} args - Arguments to update or create a Tecnologia.
     * @example
     * // Update or create a Tecnologia
     * const tecnologia = await prisma.tecnologia.upsert({
     *   create: {
     *     // ... data to create a Tecnologia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tecnologia we want to update
     *   }
     * })
     */
    upsert<T extends tecnologiaUpsertArgs>(args: SelectSubset<T, tecnologiaUpsertArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tecnologias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaCountArgs} args - Arguments to filter Tecnologias to count.
     * @example
     * // Count the number of Tecnologias
     * const count = await prisma.tecnologia.count({
     *   where: {
     *     // ... the filter for the Tecnologias we want to count
     *   }
     * })
    **/
    count<T extends tecnologiaCountArgs>(
      args?: Subset<T, tecnologiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TecnologiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tecnologia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TecnologiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TecnologiaAggregateArgs>(args: Subset<T, TecnologiaAggregateArgs>): Prisma.PrismaPromise<GetTecnologiaAggregateType<T>>

    /**
     * Group by Tecnologia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tecnologiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tecnologiaGroupByArgs['orderBy'] }
        : { orderBy?: tecnologiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tecnologiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTecnologiaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tecnologia model
   */
  readonly fields: tecnologiaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tecnologia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tecnologiaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pais<T extends paisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paisDefaultArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    indicador<T extends indicadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, indicadorDefaultArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tecnologia model
   */
  interface tecnologiaFieldRefs {
    readonly id: FieldRef<"tecnologia", 'Int'>
    readonly valor: FieldRef<"tecnologia", 'Float'>
    readonly ano: FieldRef<"tecnologia", 'Int'>
    readonly pais_id: FieldRef<"tecnologia", 'String'>
    readonly indicador_id: FieldRef<"tecnologia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tecnologia findUnique
   */
  export type tecnologiaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologia to fetch.
     */
    where: tecnologiaWhereUniqueInput
  }

  /**
   * tecnologia findUniqueOrThrow
   */
  export type tecnologiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologia to fetch.
     */
    where: tecnologiaWhereUniqueInput
  }

  /**
   * tecnologia findFirst
   */
  export type tecnologiaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologia to fetch.
     */
    where?: tecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologias to fetch.
     */
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tecnologias.
     */
    cursor?: tecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tecnologias.
     */
    distinct?: TecnologiaScalarFieldEnum | TecnologiaScalarFieldEnum[]
  }

  /**
   * tecnologia findFirstOrThrow
   */
  export type tecnologiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologia to fetch.
     */
    where?: tecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologias to fetch.
     */
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tecnologias.
     */
    cursor?: tecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tecnologias.
     */
    distinct?: TecnologiaScalarFieldEnum | TecnologiaScalarFieldEnum[]
  }

  /**
   * tecnologia findMany
   */
  export type tecnologiaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologias to fetch.
     */
    where?: tecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologias to fetch.
     */
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tecnologias.
     */
    cursor?: tecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologias.
     */
    skip?: number
    distinct?: TecnologiaScalarFieldEnum | TecnologiaScalarFieldEnum[]
  }

  /**
   * tecnologia create
   */
  export type tecnologiaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * The data needed to create a tecnologia.
     */
    data: XOR<tecnologiaCreateInput, tecnologiaUncheckedCreateInput>
  }

  /**
   * tecnologia createMany
   */
  export type tecnologiaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tecnologias.
     */
    data: tecnologiaCreateManyInput | tecnologiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tecnologia createManyAndReturn
   */
  export type tecnologiaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * The data used to create many tecnologias.
     */
    data: tecnologiaCreateManyInput | tecnologiaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tecnologia update
   */
  export type tecnologiaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * The data needed to update a tecnologia.
     */
    data: XOR<tecnologiaUpdateInput, tecnologiaUncheckedUpdateInput>
    /**
     * Choose, which tecnologia to update.
     */
    where: tecnologiaWhereUniqueInput
  }

  /**
   * tecnologia updateMany
   */
  export type tecnologiaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tecnologias.
     */
    data: XOR<tecnologiaUpdateManyMutationInput, tecnologiaUncheckedUpdateManyInput>
    /**
     * Filter which tecnologias to update
     */
    where?: tecnologiaWhereInput
    /**
     * Limit how many tecnologias to update.
     */
    limit?: number
  }

  /**
   * tecnologia updateManyAndReturn
   */
  export type tecnologiaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * The data used to update tecnologias.
     */
    data: XOR<tecnologiaUpdateManyMutationInput, tecnologiaUncheckedUpdateManyInput>
    /**
     * Filter which tecnologias to update
     */
    where?: tecnologiaWhereInput
    /**
     * Limit how many tecnologias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tecnologia upsert
   */
  export type tecnologiaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * The filter to search for the tecnologia to update in case it exists.
     */
    where: tecnologiaWhereUniqueInput
    /**
     * In case the tecnologia found by the `where` argument doesn't exist, create a new tecnologia with this data.
     */
    create: XOR<tecnologiaCreateInput, tecnologiaUncheckedCreateInput>
    /**
     * In case the tecnologia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tecnologiaUpdateInput, tecnologiaUncheckedUpdateInput>
  }

  /**
   * tecnologia delete
   */
  export type tecnologiaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter which tecnologia to delete.
     */
    where: tecnologiaWhereUniqueInput
  }

  /**
   * tecnologia deleteMany
   */
  export type tecnologiaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tecnologias to delete
     */
    where?: tecnologiaWhereInput
    /**
     * Limit how many tecnologias to delete.
     */
    limit?: number
  }

  /**
   * tecnologia without action
   */
  export type tecnologiaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tecnologia
     */
    omit?: tecnologiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
  }


  /**
   * Model demografia
   */

  export type AggregateDemografia = {
    _count: DemografiaCountAggregateOutputType | null
    _avg: DemografiaAvgAggregateOutputType | null
    _sum: DemografiaSumAggregateOutputType | null
    _min: DemografiaMinAggregateOutputType | null
    _max: DemografiaMaxAggregateOutputType | null
  }

  export type DemografiaAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type DemografiaSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
  }

  export type DemografiaMinAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type DemografiaMaxAggregateOutputType = {
    id: number | null
    valor: number | null
    ano: number | null
    pais_id: string | null
    indicador_id: string | null
  }

  export type DemografiaCountAggregateOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: number
    indicador_id: number
    _all: number
  }


  export type DemografiaAvgAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type DemografiaSumAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
  }

  export type DemografiaMinAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type DemografiaMaxAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
  }

  export type DemografiaCountAggregateInputType = {
    id?: true
    valor?: true
    ano?: true
    pais_id?: true
    indicador_id?: true
    _all?: true
  }

  export type DemografiaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which demografia to aggregate.
     */
    where?: demografiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of demografias to fetch.
     */
    orderBy?: demografiaOrderByWithRelationInput | demografiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: demografiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demografias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demografias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned demografias
    **/
    _count?: true | DemografiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DemografiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DemografiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DemografiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DemografiaMaxAggregateInputType
  }

  export type GetDemografiaAggregateType<T extends DemografiaAggregateArgs> = {
        [P in keyof T & keyof AggregateDemografia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDemografia[P]>
      : GetScalarType<T[P], AggregateDemografia[P]>
  }




  export type demografiaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: demografiaWhereInput
    orderBy?: demografiaOrderByWithAggregationInput | demografiaOrderByWithAggregationInput[]
    by: DemografiaScalarFieldEnum[] | DemografiaScalarFieldEnum
    having?: demografiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DemografiaCountAggregateInputType | true
    _avg?: DemografiaAvgAggregateInputType
    _sum?: DemografiaSumAggregateInputType
    _min?: DemografiaMinAggregateInputType
    _max?: DemografiaMaxAggregateInputType
  }

  export type DemografiaGroupByOutputType = {
    id: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
    _count: DemografiaCountAggregateOutputType | null
    _avg: DemografiaAvgAggregateOutputType | null
    _sum: DemografiaSumAggregateOutputType | null
    _min: DemografiaMinAggregateOutputType | null
    _max: DemografiaMaxAggregateOutputType | null
  }

  type GetDemografiaGroupByPayload<T extends demografiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DemografiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DemografiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DemografiaGroupByOutputType[P]>
            : GetScalarType<T[P], DemografiaGroupByOutputType[P]>
        }
      >
    >


  export type demografiaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["demografia"]>

  export type demografiaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["demografia"]>

  export type demografiaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["demografia"]>

  export type demografiaSelectScalar = {
    id?: boolean
    valor?: boolean
    ano?: boolean
    pais_id?: boolean
    indicador_id?: boolean
  }

  export type demografiaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valor" | "ano" | "pais_id" | "indicador_id", ExtArgs["result"]["demografia"]>
  export type demografiaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type demografiaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }
  export type demografiaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    indicador?: boolean | indicadorDefaultArgs<ExtArgs>
  }

  export type $demografiaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "demografia"
    objects: {
      pais: Prisma.$paisPayload<ExtArgs>
      indicador: Prisma.$indicadorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valor: number
      ano: number
      pais_id: string
      indicador_id: string
    }, ExtArgs["result"]["demografia"]>
    composites: {}
  }

  type demografiaGetPayload<S extends boolean | null | undefined | demografiaDefaultArgs> = $Result.GetResult<Prisma.$demografiaPayload, S>

  type demografiaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<demografiaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DemografiaCountAggregateInputType | true
    }

  export interface demografiaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['demografia'], meta: { name: 'demografia' } }
    /**
     * Find zero or one Demografia that matches the filter.
     * @param {demografiaFindUniqueArgs} args - Arguments to find a Demografia
     * @example
     * // Get one Demografia
     * const demografia = await prisma.demografia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends demografiaFindUniqueArgs>(args: SelectSubset<T, demografiaFindUniqueArgs<ExtArgs>>): Prisma__demografiaClient<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Demografia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {demografiaFindUniqueOrThrowArgs} args - Arguments to find a Demografia
     * @example
     * // Get one Demografia
     * const demografia = await prisma.demografia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends demografiaFindUniqueOrThrowArgs>(args: SelectSubset<T, demografiaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__demografiaClient<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Demografia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demografiaFindFirstArgs} args - Arguments to find a Demografia
     * @example
     * // Get one Demografia
     * const demografia = await prisma.demografia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends demografiaFindFirstArgs>(args?: SelectSubset<T, demografiaFindFirstArgs<ExtArgs>>): Prisma__demografiaClient<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Demografia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demografiaFindFirstOrThrowArgs} args - Arguments to find a Demografia
     * @example
     * // Get one Demografia
     * const demografia = await prisma.demografia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends demografiaFindFirstOrThrowArgs>(args?: SelectSubset<T, demografiaFindFirstOrThrowArgs<ExtArgs>>): Prisma__demografiaClient<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Demografias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demografiaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Demografias
     * const demografias = await prisma.demografia.findMany()
     * 
     * // Get first 10 Demografias
     * const demografias = await prisma.demografia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const demografiaWithIdOnly = await prisma.demografia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends demografiaFindManyArgs>(args?: SelectSubset<T, demografiaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Demografia.
     * @param {demografiaCreateArgs} args - Arguments to create a Demografia.
     * @example
     * // Create one Demografia
     * const Demografia = await prisma.demografia.create({
     *   data: {
     *     // ... data to create a Demografia
     *   }
     * })
     * 
     */
    create<T extends demografiaCreateArgs>(args: SelectSubset<T, demografiaCreateArgs<ExtArgs>>): Prisma__demografiaClient<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Demografias.
     * @param {demografiaCreateManyArgs} args - Arguments to create many Demografias.
     * @example
     * // Create many Demografias
     * const demografia = await prisma.demografia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends demografiaCreateManyArgs>(args?: SelectSubset<T, demografiaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Demografias and returns the data saved in the database.
     * @param {demografiaCreateManyAndReturnArgs} args - Arguments to create many Demografias.
     * @example
     * // Create many Demografias
     * const demografia = await prisma.demografia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Demografias and only return the `id`
     * const demografiaWithIdOnly = await prisma.demografia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends demografiaCreateManyAndReturnArgs>(args?: SelectSubset<T, demografiaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Demografia.
     * @param {demografiaDeleteArgs} args - Arguments to delete one Demografia.
     * @example
     * // Delete one Demografia
     * const Demografia = await prisma.demografia.delete({
     *   where: {
     *     // ... filter to delete one Demografia
     *   }
     * })
     * 
     */
    delete<T extends demografiaDeleteArgs>(args: SelectSubset<T, demografiaDeleteArgs<ExtArgs>>): Prisma__demografiaClient<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Demografia.
     * @param {demografiaUpdateArgs} args - Arguments to update one Demografia.
     * @example
     * // Update one Demografia
     * const demografia = await prisma.demografia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends demografiaUpdateArgs>(args: SelectSubset<T, demografiaUpdateArgs<ExtArgs>>): Prisma__demografiaClient<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Demografias.
     * @param {demografiaDeleteManyArgs} args - Arguments to filter Demografias to delete.
     * @example
     * // Delete a few Demografias
     * const { count } = await prisma.demografia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends demografiaDeleteManyArgs>(args?: SelectSubset<T, demografiaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Demografias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demografiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Demografias
     * const demografia = await prisma.demografia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends demografiaUpdateManyArgs>(args: SelectSubset<T, demografiaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Demografias and returns the data updated in the database.
     * @param {demografiaUpdateManyAndReturnArgs} args - Arguments to update many Demografias.
     * @example
     * // Update many Demografias
     * const demografia = await prisma.demografia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Demografias and only return the `id`
     * const demografiaWithIdOnly = await prisma.demografia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends demografiaUpdateManyAndReturnArgs>(args: SelectSubset<T, demografiaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Demografia.
     * @param {demografiaUpsertArgs} args - Arguments to update or create a Demografia.
     * @example
     * // Update or create a Demografia
     * const demografia = await prisma.demografia.upsert({
     *   create: {
     *     // ... data to create a Demografia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Demografia we want to update
     *   }
     * })
     */
    upsert<T extends demografiaUpsertArgs>(args: SelectSubset<T, demografiaUpsertArgs<ExtArgs>>): Prisma__demografiaClient<$Result.GetResult<Prisma.$demografiaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Demografias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demografiaCountArgs} args - Arguments to filter Demografias to count.
     * @example
     * // Count the number of Demografias
     * const count = await prisma.demografia.count({
     *   where: {
     *     // ... the filter for the Demografias we want to count
     *   }
     * })
    **/
    count<T extends demografiaCountArgs>(
      args?: Subset<T, demografiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DemografiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Demografia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DemografiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DemografiaAggregateArgs>(args: Subset<T, DemografiaAggregateArgs>): Prisma.PrismaPromise<GetDemografiaAggregateType<T>>

    /**
     * Group by Demografia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {demografiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends demografiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: demografiaGroupByArgs['orderBy'] }
        : { orderBy?: demografiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, demografiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDemografiaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the demografia model
   */
  readonly fields: demografiaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for demografia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__demografiaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pais<T extends paisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paisDefaultArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    indicador<T extends indicadorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, indicadorDefaultArgs<ExtArgs>>): Prisma__indicadorClient<$Result.GetResult<Prisma.$indicadorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the demografia model
   */
  interface demografiaFieldRefs {
    readonly id: FieldRef<"demografia", 'Int'>
    readonly valor: FieldRef<"demografia", 'Float'>
    readonly ano: FieldRef<"demografia", 'Int'>
    readonly pais_id: FieldRef<"demografia", 'String'>
    readonly indicador_id: FieldRef<"demografia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * demografia findUnique
   */
  export type demografiaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    /**
     * Filter, which demografia to fetch.
     */
    where: demografiaWhereUniqueInput
  }

  /**
   * demografia findUniqueOrThrow
   */
  export type demografiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    /**
     * Filter, which demografia to fetch.
     */
    where: demografiaWhereUniqueInput
  }

  /**
   * demografia findFirst
   */
  export type demografiaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    /**
     * Filter, which demografia to fetch.
     */
    where?: demografiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of demografias to fetch.
     */
    orderBy?: demografiaOrderByWithRelationInput | demografiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for demografias.
     */
    cursor?: demografiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demografias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demografias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of demografias.
     */
    distinct?: DemografiaScalarFieldEnum | DemografiaScalarFieldEnum[]
  }

  /**
   * demografia findFirstOrThrow
   */
  export type demografiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    /**
     * Filter, which demografia to fetch.
     */
    where?: demografiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of demografias to fetch.
     */
    orderBy?: demografiaOrderByWithRelationInput | demografiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for demografias.
     */
    cursor?: demografiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demografias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demografias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of demografias.
     */
    distinct?: DemografiaScalarFieldEnum | DemografiaScalarFieldEnum[]
  }

  /**
   * demografia findMany
   */
  export type demografiaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    /**
     * Filter, which demografias to fetch.
     */
    where?: demografiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of demografias to fetch.
     */
    orderBy?: demografiaOrderByWithRelationInput | demografiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing demografias.
     */
    cursor?: demografiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demografias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demografias.
     */
    skip?: number
    distinct?: DemografiaScalarFieldEnum | DemografiaScalarFieldEnum[]
  }

  /**
   * demografia create
   */
  export type demografiaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    /**
     * The data needed to create a demografia.
     */
    data: XOR<demografiaCreateInput, demografiaUncheckedCreateInput>
  }

  /**
   * demografia createMany
   */
  export type demografiaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many demografias.
     */
    data: demografiaCreateManyInput | demografiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * demografia createManyAndReturn
   */
  export type demografiaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * The data used to create many demografias.
     */
    data: demografiaCreateManyInput | demografiaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * demografia update
   */
  export type demografiaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    /**
     * The data needed to update a demografia.
     */
    data: XOR<demografiaUpdateInput, demografiaUncheckedUpdateInput>
    /**
     * Choose, which demografia to update.
     */
    where: demografiaWhereUniqueInput
  }

  /**
   * demografia updateMany
   */
  export type demografiaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update demografias.
     */
    data: XOR<demografiaUpdateManyMutationInput, demografiaUncheckedUpdateManyInput>
    /**
     * Filter which demografias to update
     */
    where?: demografiaWhereInput
    /**
     * Limit how many demografias to update.
     */
    limit?: number
  }

  /**
   * demografia updateManyAndReturn
   */
  export type demografiaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * The data used to update demografias.
     */
    data: XOR<demografiaUpdateManyMutationInput, demografiaUncheckedUpdateManyInput>
    /**
     * Filter which demografias to update
     */
    where?: demografiaWhereInput
    /**
     * Limit how many demografias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * demografia upsert
   */
  export type demografiaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    /**
     * The filter to search for the demografia to update in case it exists.
     */
    where: demografiaWhereUniqueInput
    /**
     * In case the demografia found by the `where` argument doesn't exist, create a new demografia with this data.
     */
    create: XOR<demografiaCreateInput, demografiaUncheckedCreateInput>
    /**
     * In case the demografia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<demografiaUpdateInput, demografiaUncheckedUpdateInput>
  }

  /**
   * demografia delete
   */
  export type demografiaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
    /**
     * Filter which demografia to delete.
     */
    where: demografiaWhereUniqueInput
  }

  /**
   * demografia deleteMany
   */
  export type demografiaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which demografias to delete
     */
    where?: demografiaWhereInput
    /**
     * Limit how many demografias to delete.
     */
    limit?: number
  }

  /**
   * demografia without action
   */
  export type demografiaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the demografia
     */
    select?: demografiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the demografia
     */
    omit?: demografiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: demografiaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PaisScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    iso3: 'iso3'
  };

  export type PaisScalarFieldEnum = (typeof PaisScalarFieldEnum)[keyof typeof PaisScalarFieldEnum]


  export const IndicadorScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    categoria: 'categoria'
  };

  export type IndicadorScalarFieldEnum = (typeof IndicadorScalarFieldEnum)[keyof typeof IndicadorScalarFieldEnum]


  export const SaudeScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    ano: 'ano',
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type SaudeScalarFieldEnum = (typeof SaudeScalarFieldEnum)[keyof typeof SaudeScalarFieldEnum]


  export const EconomiaScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    ano: 'ano',
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type EconomiaScalarFieldEnum = (typeof EconomiaScalarFieldEnum)[keyof typeof EconomiaScalarFieldEnum]


  export const AmbienteScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    ano: 'ano',
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type AmbienteScalarFieldEnum = (typeof AmbienteScalarFieldEnum)[keyof typeof AmbienteScalarFieldEnum]


  export const TecnologiaScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    ano: 'ano',
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type TecnologiaScalarFieldEnum = (typeof TecnologiaScalarFieldEnum)[keyof typeof TecnologiaScalarFieldEnum]


  export const DemografiaScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    ano: 'ano',
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type DemografiaScalarFieldEnum = (typeof DemografiaScalarFieldEnum)[keyof typeof DemografiaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const paisOrderByRelevanceFieldEnum: {
    id: 'id',
    nome: 'nome',
    iso3: 'iso3'
  };

  export type paisOrderByRelevanceFieldEnum = (typeof paisOrderByRelevanceFieldEnum)[keyof typeof paisOrderByRelevanceFieldEnum]


  export const indicadorOrderByRelevanceFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type indicadorOrderByRelevanceFieldEnum = (typeof indicadorOrderByRelevanceFieldEnum)[keyof typeof indicadorOrderByRelevanceFieldEnum]


  export const saudeOrderByRelevanceFieldEnum: {
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type saudeOrderByRelevanceFieldEnum = (typeof saudeOrderByRelevanceFieldEnum)[keyof typeof saudeOrderByRelevanceFieldEnum]


  export const economiaOrderByRelevanceFieldEnum: {
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type economiaOrderByRelevanceFieldEnum = (typeof economiaOrderByRelevanceFieldEnum)[keyof typeof economiaOrderByRelevanceFieldEnum]


  export const ambienteOrderByRelevanceFieldEnum: {
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type ambienteOrderByRelevanceFieldEnum = (typeof ambienteOrderByRelevanceFieldEnum)[keyof typeof ambienteOrderByRelevanceFieldEnum]


  export const tecnologiaOrderByRelevanceFieldEnum: {
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type tecnologiaOrderByRelevanceFieldEnum = (typeof tecnologiaOrderByRelevanceFieldEnum)[keyof typeof tecnologiaOrderByRelevanceFieldEnum]


  export const demografiaOrderByRelevanceFieldEnum: {
    pais_id: 'pais_id',
    indicador_id: 'indicador_id'
  };

  export type demografiaOrderByRelevanceFieldEnum = (typeof demografiaOrderByRelevanceFieldEnum)[keyof typeof demografiaOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'categoria'
   */
  export type EnumcategoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'categoria'>
    


  /**
   * Reference to a field of type 'categoria[]'
   */
  export type ListEnumcategoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'categoria[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type paisWhereInput = {
    AND?: paisWhereInput | paisWhereInput[]
    OR?: paisWhereInput[]
    NOT?: paisWhereInput | paisWhereInput[]
    id?: StringFilter<"pais"> | string
    nome?: StringFilter<"pais"> | string
    iso3?: StringFilter<"pais"> | string
    saude?: SaudeListRelationFilter
    economia?: EconomiaListRelationFilter
    ambiente?: AmbienteListRelationFilter
    tecnologia?: TecnologiaListRelationFilter
    demografia?: DemografiaListRelationFilter
  }

  export type paisOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    iso3?: SortOrder
    saude?: saudeOrderByRelationAggregateInput
    economia?: economiaOrderByRelationAggregateInput
    ambiente?: ambienteOrderByRelationAggregateInput
    tecnologia?: tecnologiaOrderByRelationAggregateInput
    demografia?: demografiaOrderByRelationAggregateInput
    _relevance?: paisOrderByRelevanceInput
  }

  export type paisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    iso3?: string
    AND?: paisWhereInput | paisWhereInput[]
    OR?: paisWhereInput[]
    NOT?: paisWhereInput | paisWhereInput[]
    nome?: StringFilter<"pais"> | string
    saude?: SaudeListRelationFilter
    economia?: EconomiaListRelationFilter
    ambiente?: AmbienteListRelationFilter
    tecnologia?: TecnologiaListRelationFilter
    demografia?: DemografiaListRelationFilter
  }, "id" | "iso3">

  export type paisOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    iso3?: SortOrder
    _count?: paisCountOrderByAggregateInput
    _max?: paisMaxOrderByAggregateInput
    _min?: paisMinOrderByAggregateInput
  }

  export type paisScalarWhereWithAggregatesInput = {
    AND?: paisScalarWhereWithAggregatesInput | paisScalarWhereWithAggregatesInput[]
    OR?: paisScalarWhereWithAggregatesInput[]
    NOT?: paisScalarWhereWithAggregatesInput | paisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"pais"> | string
    nome?: StringWithAggregatesFilter<"pais"> | string
    iso3?: StringWithAggregatesFilter<"pais"> | string
  }

  export type indicadorWhereInput = {
    AND?: indicadorWhereInput | indicadorWhereInput[]
    OR?: indicadorWhereInput[]
    NOT?: indicadorWhereInput | indicadorWhereInput[]
    id?: StringFilter<"indicador"> | string
    nome?: StringFilter<"indicador"> | string
    categoria?: EnumcategoriaFilter<"indicador"> | $Enums.categoria
    saude?: SaudeListRelationFilter
    economia?: EconomiaListRelationFilter
    ambiente?: AmbienteListRelationFilter
    tecnologia?: TecnologiaListRelationFilter
    demografia?: DemografiaListRelationFilter
  }

  export type indicadorOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    saude?: saudeOrderByRelationAggregateInput
    economia?: economiaOrderByRelationAggregateInput
    ambiente?: ambienteOrderByRelationAggregateInput
    tecnologia?: tecnologiaOrderByRelationAggregateInput
    demografia?: demografiaOrderByRelationAggregateInput
    _relevance?: indicadorOrderByRelevanceInput
  }

  export type indicadorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: indicadorWhereInput | indicadorWhereInput[]
    OR?: indicadorWhereInput[]
    NOT?: indicadorWhereInput | indicadorWhereInput[]
    nome?: StringFilter<"indicador"> | string
    categoria?: EnumcategoriaFilter<"indicador"> | $Enums.categoria
    saude?: SaudeListRelationFilter
    economia?: EconomiaListRelationFilter
    ambiente?: AmbienteListRelationFilter
    tecnologia?: TecnologiaListRelationFilter
    demografia?: DemografiaListRelationFilter
  }, "id">

  export type indicadorOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
    _count?: indicadorCountOrderByAggregateInput
    _max?: indicadorMaxOrderByAggregateInput
    _min?: indicadorMinOrderByAggregateInput
  }

  export type indicadorScalarWhereWithAggregatesInput = {
    AND?: indicadorScalarWhereWithAggregatesInput | indicadorScalarWhereWithAggregatesInput[]
    OR?: indicadorScalarWhereWithAggregatesInput[]
    NOT?: indicadorScalarWhereWithAggregatesInput | indicadorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"indicador"> | string
    nome?: StringWithAggregatesFilter<"indicador"> | string
    categoria?: EnumcategoriaWithAggregatesFilter<"indicador"> | $Enums.categoria
  }

  export type saudeWhereInput = {
    AND?: saudeWhereInput | saudeWhereInput[]
    OR?: saudeWhereInput[]
    NOT?: saudeWhereInput | saudeWhereInput[]
    id?: IntFilter<"saude"> | number
    valor?: FloatFilter<"saude"> | number
    ano?: IntFilter<"saude"> | number
    pais_id?: StringFilter<"saude"> | string
    indicador_id?: StringFilter<"saude"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }

  export type saudeOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    pais?: paisOrderByWithRelationInput
    indicador?: indicadorOrderByWithRelationInput
    _relevance?: saudeOrderByRelevanceInput
  }

  export type saudeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pais_id_indicador_id_ano?: saudePais_idIndicador_idAnoCompoundUniqueInput
    AND?: saudeWhereInput | saudeWhereInput[]
    OR?: saudeWhereInput[]
    NOT?: saudeWhereInput | saudeWhereInput[]
    valor?: FloatFilter<"saude"> | number
    ano?: IntFilter<"saude"> | number
    pais_id?: StringFilter<"saude"> | string
    indicador_id?: StringFilter<"saude"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }, "id" | "pais_id_indicador_id_ano">

  export type saudeOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    _count?: saudeCountOrderByAggregateInput
    _avg?: saudeAvgOrderByAggregateInput
    _max?: saudeMaxOrderByAggregateInput
    _min?: saudeMinOrderByAggregateInput
    _sum?: saudeSumOrderByAggregateInput
  }

  export type saudeScalarWhereWithAggregatesInput = {
    AND?: saudeScalarWhereWithAggregatesInput | saudeScalarWhereWithAggregatesInput[]
    OR?: saudeScalarWhereWithAggregatesInput[]
    NOT?: saudeScalarWhereWithAggregatesInput | saudeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"saude"> | number
    valor?: FloatWithAggregatesFilter<"saude"> | number
    ano?: IntWithAggregatesFilter<"saude"> | number
    pais_id?: StringWithAggregatesFilter<"saude"> | string
    indicador_id?: StringWithAggregatesFilter<"saude"> | string
  }

  export type economiaWhereInput = {
    AND?: economiaWhereInput | economiaWhereInput[]
    OR?: economiaWhereInput[]
    NOT?: economiaWhereInput | economiaWhereInput[]
    id?: IntFilter<"economia"> | number
    valor?: FloatFilter<"economia"> | number
    ano?: IntFilter<"economia"> | number
    pais_id?: StringFilter<"economia"> | string
    indicador_id?: StringFilter<"economia"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }

  export type economiaOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    pais?: paisOrderByWithRelationInput
    indicador?: indicadorOrderByWithRelationInput
    _relevance?: economiaOrderByRelevanceInput
  }

  export type economiaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pais_id_indicador_id_ano?: economiaPais_idIndicador_idAnoCompoundUniqueInput
    AND?: economiaWhereInput | economiaWhereInput[]
    OR?: economiaWhereInput[]
    NOT?: economiaWhereInput | economiaWhereInput[]
    valor?: FloatFilter<"economia"> | number
    ano?: IntFilter<"economia"> | number
    pais_id?: StringFilter<"economia"> | string
    indicador_id?: StringFilter<"economia"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }, "id" | "pais_id_indicador_id_ano">

  export type economiaOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    _count?: economiaCountOrderByAggregateInput
    _avg?: economiaAvgOrderByAggregateInput
    _max?: economiaMaxOrderByAggregateInput
    _min?: economiaMinOrderByAggregateInput
    _sum?: economiaSumOrderByAggregateInput
  }

  export type economiaScalarWhereWithAggregatesInput = {
    AND?: economiaScalarWhereWithAggregatesInput | economiaScalarWhereWithAggregatesInput[]
    OR?: economiaScalarWhereWithAggregatesInput[]
    NOT?: economiaScalarWhereWithAggregatesInput | economiaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"economia"> | number
    valor?: FloatWithAggregatesFilter<"economia"> | number
    ano?: IntWithAggregatesFilter<"economia"> | number
    pais_id?: StringWithAggregatesFilter<"economia"> | string
    indicador_id?: StringWithAggregatesFilter<"economia"> | string
  }

  export type ambienteWhereInput = {
    AND?: ambienteWhereInput | ambienteWhereInput[]
    OR?: ambienteWhereInput[]
    NOT?: ambienteWhereInput | ambienteWhereInput[]
    id?: IntFilter<"ambiente"> | number
    valor?: FloatFilter<"ambiente"> | number
    ano?: IntFilter<"ambiente"> | number
    pais_id?: StringFilter<"ambiente"> | string
    indicador_id?: StringFilter<"ambiente"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }

  export type ambienteOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    pais?: paisOrderByWithRelationInput
    indicador?: indicadorOrderByWithRelationInput
    _relevance?: ambienteOrderByRelevanceInput
  }

  export type ambienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pais_id_indicador_id_ano?: ambientePais_idIndicador_idAnoCompoundUniqueInput
    AND?: ambienteWhereInput | ambienteWhereInput[]
    OR?: ambienteWhereInput[]
    NOT?: ambienteWhereInput | ambienteWhereInput[]
    valor?: FloatFilter<"ambiente"> | number
    ano?: IntFilter<"ambiente"> | number
    pais_id?: StringFilter<"ambiente"> | string
    indicador_id?: StringFilter<"ambiente"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }, "id" | "pais_id_indicador_id_ano">

  export type ambienteOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    _count?: ambienteCountOrderByAggregateInput
    _avg?: ambienteAvgOrderByAggregateInput
    _max?: ambienteMaxOrderByAggregateInput
    _min?: ambienteMinOrderByAggregateInput
    _sum?: ambienteSumOrderByAggregateInput
  }

  export type ambienteScalarWhereWithAggregatesInput = {
    AND?: ambienteScalarWhereWithAggregatesInput | ambienteScalarWhereWithAggregatesInput[]
    OR?: ambienteScalarWhereWithAggregatesInput[]
    NOT?: ambienteScalarWhereWithAggregatesInput | ambienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ambiente"> | number
    valor?: FloatWithAggregatesFilter<"ambiente"> | number
    ano?: IntWithAggregatesFilter<"ambiente"> | number
    pais_id?: StringWithAggregatesFilter<"ambiente"> | string
    indicador_id?: StringWithAggregatesFilter<"ambiente"> | string
  }

  export type tecnologiaWhereInput = {
    AND?: tecnologiaWhereInput | tecnologiaWhereInput[]
    OR?: tecnologiaWhereInput[]
    NOT?: tecnologiaWhereInput | tecnologiaWhereInput[]
    id?: IntFilter<"tecnologia"> | number
    valor?: FloatFilter<"tecnologia"> | number
    ano?: IntFilter<"tecnologia"> | number
    pais_id?: StringFilter<"tecnologia"> | string
    indicador_id?: StringFilter<"tecnologia"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }

  export type tecnologiaOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    pais?: paisOrderByWithRelationInput
    indicador?: indicadorOrderByWithRelationInput
    _relevance?: tecnologiaOrderByRelevanceInput
  }

  export type tecnologiaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pais_id_indicador_id_ano?: tecnologiaPais_idIndicador_idAnoCompoundUniqueInput
    AND?: tecnologiaWhereInput | tecnologiaWhereInput[]
    OR?: tecnologiaWhereInput[]
    NOT?: tecnologiaWhereInput | tecnologiaWhereInput[]
    valor?: FloatFilter<"tecnologia"> | number
    ano?: IntFilter<"tecnologia"> | number
    pais_id?: StringFilter<"tecnologia"> | string
    indicador_id?: StringFilter<"tecnologia"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }, "id" | "pais_id_indicador_id_ano">

  export type tecnologiaOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    _count?: tecnologiaCountOrderByAggregateInput
    _avg?: tecnologiaAvgOrderByAggregateInput
    _max?: tecnologiaMaxOrderByAggregateInput
    _min?: tecnologiaMinOrderByAggregateInput
    _sum?: tecnologiaSumOrderByAggregateInput
  }

  export type tecnologiaScalarWhereWithAggregatesInput = {
    AND?: tecnologiaScalarWhereWithAggregatesInput | tecnologiaScalarWhereWithAggregatesInput[]
    OR?: tecnologiaScalarWhereWithAggregatesInput[]
    NOT?: tecnologiaScalarWhereWithAggregatesInput | tecnologiaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tecnologia"> | number
    valor?: FloatWithAggregatesFilter<"tecnologia"> | number
    ano?: IntWithAggregatesFilter<"tecnologia"> | number
    pais_id?: StringWithAggregatesFilter<"tecnologia"> | string
    indicador_id?: StringWithAggregatesFilter<"tecnologia"> | string
  }

  export type demografiaWhereInput = {
    AND?: demografiaWhereInput | demografiaWhereInput[]
    OR?: demografiaWhereInput[]
    NOT?: demografiaWhereInput | demografiaWhereInput[]
    id?: IntFilter<"demografia"> | number
    valor?: FloatFilter<"demografia"> | number
    ano?: IntFilter<"demografia"> | number
    pais_id?: StringFilter<"demografia"> | string
    indicador_id?: StringFilter<"demografia"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }

  export type demografiaOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    pais?: paisOrderByWithRelationInput
    indicador?: indicadorOrderByWithRelationInput
    _relevance?: demografiaOrderByRelevanceInput
  }

  export type demografiaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pais_id_indicador_id_ano?: demografiaPais_idIndicador_idAnoCompoundUniqueInput
    AND?: demografiaWhereInput | demografiaWhereInput[]
    OR?: demografiaWhereInput[]
    NOT?: demografiaWhereInput | demografiaWhereInput[]
    valor?: FloatFilter<"demografia"> | number
    ano?: IntFilter<"demografia"> | number
    pais_id?: StringFilter<"demografia"> | string
    indicador_id?: StringFilter<"demografia"> | string
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    indicador?: XOR<IndicadorScalarRelationFilter, indicadorWhereInput>
  }, "id" | "pais_id_indicador_id_ano">

  export type demografiaOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
    _count?: demografiaCountOrderByAggregateInput
    _avg?: demografiaAvgOrderByAggregateInput
    _max?: demografiaMaxOrderByAggregateInput
    _min?: demografiaMinOrderByAggregateInput
    _sum?: demografiaSumOrderByAggregateInput
  }

  export type demografiaScalarWhereWithAggregatesInput = {
    AND?: demografiaScalarWhereWithAggregatesInput | demografiaScalarWhereWithAggregatesInput[]
    OR?: demografiaScalarWhereWithAggregatesInput[]
    NOT?: demografiaScalarWhereWithAggregatesInput | demografiaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"demografia"> | number
    valor?: FloatWithAggregatesFilter<"demografia"> | number
    ano?: IntWithAggregatesFilter<"demografia"> | number
    pais_id?: StringWithAggregatesFilter<"demografia"> | string
    indicador_id?: StringWithAggregatesFilter<"demografia"> | string
  }

  export type paisCreateInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeCreateNestedManyWithoutPaisInput
    economia?: economiaCreateNestedManyWithoutPaisInput
    ambiente?: ambienteCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaCreateNestedManyWithoutPaisInput
    demografia?: demografiaCreateNestedManyWithoutPaisInput
  }

  export type paisUncheckedCreateInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeUncheckedCreateNestedManyWithoutPaisInput
    economia?: economiaUncheckedCreateNestedManyWithoutPaisInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutPaisInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutPaisInput
  }

  export type paisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUpdateManyWithoutPaisNestedInput
    economia?: economiaUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUpdateManyWithoutPaisNestedInput
  }

  export type paisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUncheckedUpdateManyWithoutPaisNestedInput
    economia?: economiaUncheckedUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutPaisNestedInput
  }

  export type paisCreateManyInput = {
    id: string
    nome: string
    iso3: string
  }

  export type paisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
  }

  export type paisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
  }

  export type indicadorCreateInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeCreateNestedManyWithoutIndicadorInput
    economia?: economiaCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorUncheckedCreateInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeUncheckedCreateNestedManyWithoutIndicadorInput
    economia?: economiaUncheckedCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUpdateManyWithoutIndicadorNestedInput
    economia?: economiaUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUpdateManyWithoutIndicadorNestedInput
  }

  export type indicadorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUncheckedUpdateManyWithoutIndicadorNestedInput
    economia?: economiaUncheckedUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutIndicadorNestedInput
  }

  export type indicadorCreateManyInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
  }

  export type indicadorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
  }

  export type indicadorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
  }

  export type saudeCreateInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutSaudeInput
    indicador: indicadorCreateNestedOneWithoutSaudeInput
  }

  export type saudeUncheckedCreateInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type saudeUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutSaudeNestedInput
    indicador?: indicadorUpdateOneRequiredWithoutSaudeNestedInput
  }

  export type saudeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type saudeCreateManyInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type saudeUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type saudeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type economiaCreateInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutEconomiaInput
    indicador: indicadorCreateNestedOneWithoutEconomiaInput
  }

  export type economiaUncheckedCreateInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type economiaUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutEconomiaNestedInput
    indicador?: indicadorUpdateOneRequiredWithoutEconomiaNestedInput
  }

  export type economiaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type economiaCreateManyInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type economiaUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type economiaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type ambienteCreateInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutAmbienteInput
    indicador: indicadorCreateNestedOneWithoutAmbienteInput
  }

  export type ambienteUncheckedCreateInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type ambienteUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutAmbienteNestedInput
    indicador?: indicadorUpdateOneRequiredWithoutAmbienteNestedInput
  }

  export type ambienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type ambienteCreateManyInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type ambienteUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type ambienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type tecnologiaCreateInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutTecnologiaInput
    indicador: indicadorCreateNestedOneWithoutTecnologiaInput
  }

  export type tecnologiaUncheckedCreateInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type tecnologiaUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutTecnologiaNestedInput
    indicador?: indicadorUpdateOneRequiredWithoutTecnologiaNestedInput
  }

  export type tecnologiaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type tecnologiaCreateManyInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type tecnologiaUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type tecnologiaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type demografiaCreateInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutDemografiaInput
    indicador: indicadorCreateNestedOneWithoutDemografiaInput
  }

  export type demografiaUncheckedCreateInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type demografiaUpdateInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutDemografiaNestedInput
    indicador?: indicadorUpdateOneRequiredWithoutDemografiaNestedInput
  }

  export type demografiaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type demografiaCreateManyInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
    indicador_id: string
  }

  export type demografiaUpdateManyMutationInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type demografiaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type SaudeListRelationFilter = {
    every?: saudeWhereInput
    some?: saudeWhereInput
    none?: saudeWhereInput
  }

  export type EconomiaListRelationFilter = {
    every?: economiaWhereInput
    some?: economiaWhereInput
    none?: economiaWhereInput
  }

  export type AmbienteListRelationFilter = {
    every?: ambienteWhereInput
    some?: ambienteWhereInput
    none?: ambienteWhereInput
  }

  export type TecnologiaListRelationFilter = {
    every?: tecnologiaWhereInput
    some?: tecnologiaWhereInput
    none?: tecnologiaWhereInput
  }

  export type DemografiaListRelationFilter = {
    every?: demografiaWhereInput
    some?: demografiaWhereInput
    none?: demografiaWhereInput
  }

  export type saudeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type economiaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ambienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tecnologiaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type demografiaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paisOrderByRelevanceInput = {
    fields: paisOrderByRelevanceFieldEnum | paisOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type paisCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    iso3?: SortOrder
  }

  export type paisMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    iso3?: SortOrder
  }

  export type paisMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    iso3?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumcategoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.categoria | EnumcategoriaFieldRefInput<$PrismaModel>
    in?: $Enums.categoria[] | ListEnumcategoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.categoria[] | ListEnumcategoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumcategoriaFilter<$PrismaModel> | $Enums.categoria
  }

  export type indicadorOrderByRelevanceInput = {
    fields: indicadorOrderByRelevanceFieldEnum | indicadorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type indicadorCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
  }

  export type indicadorMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
  }

  export type indicadorMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    categoria?: SortOrder
  }

  export type EnumcategoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.categoria | EnumcategoriaFieldRefInput<$PrismaModel>
    in?: $Enums.categoria[] | ListEnumcategoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.categoria[] | ListEnumcategoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumcategoriaWithAggregatesFilter<$PrismaModel> | $Enums.categoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcategoriaFilter<$PrismaModel>
    _max?: NestedEnumcategoriaFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PaisScalarRelationFilter = {
    is?: paisWhereInput
    isNot?: paisWhereInput
  }

  export type IndicadorScalarRelationFilter = {
    is?: indicadorWhereInput
    isNot?: indicadorWhereInput
  }

  export type saudeOrderByRelevanceInput = {
    fields: saudeOrderByRelevanceFieldEnum | saudeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type saudePais_idIndicador_idAnoCompoundUniqueInput = {
    pais_id: string
    indicador_id: string
    ano: number
  }

  export type saudeCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type saudeAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type saudeMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type saudeMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type saudeSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type economiaOrderByRelevanceInput = {
    fields: economiaOrderByRelevanceFieldEnum | economiaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type economiaPais_idIndicador_idAnoCompoundUniqueInput = {
    pais_id: string
    indicador_id: string
    ano: number
  }

  export type economiaCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type economiaAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type economiaMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type economiaMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type economiaSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type ambienteOrderByRelevanceInput = {
    fields: ambienteOrderByRelevanceFieldEnum | ambienteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ambientePais_idIndicador_idAnoCompoundUniqueInput = {
    pais_id: string
    indicador_id: string
    ano: number
  }

  export type ambienteCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type ambienteAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type ambienteMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type ambienteMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type ambienteSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type tecnologiaOrderByRelevanceInput = {
    fields: tecnologiaOrderByRelevanceFieldEnum | tecnologiaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tecnologiaPais_idIndicador_idAnoCompoundUniqueInput = {
    pais_id: string
    indicador_id: string
    ano: number
  }

  export type tecnologiaCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type tecnologiaAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type tecnologiaMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type tecnologiaMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type tecnologiaSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type demografiaOrderByRelevanceInput = {
    fields: demografiaOrderByRelevanceFieldEnum | demografiaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type demografiaPais_idIndicador_idAnoCompoundUniqueInput = {
    pais_id: string
    indicador_id: string
    ano: number
  }

  export type demografiaCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type demografiaAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type demografiaMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type demografiaMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
    pais_id?: SortOrder
    indicador_id?: SortOrder
  }

  export type demografiaSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ano?: SortOrder
  }

  export type saudeCreateNestedManyWithoutPaisInput = {
    create?: XOR<saudeCreateWithoutPaisInput, saudeUncheckedCreateWithoutPaisInput> | saudeCreateWithoutPaisInput[] | saudeUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: saudeCreateOrConnectWithoutPaisInput | saudeCreateOrConnectWithoutPaisInput[]
    createMany?: saudeCreateManyPaisInputEnvelope
    connect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
  }

  export type economiaCreateNestedManyWithoutPaisInput = {
    create?: XOR<economiaCreateWithoutPaisInput, economiaUncheckedCreateWithoutPaisInput> | economiaCreateWithoutPaisInput[] | economiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: economiaCreateOrConnectWithoutPaisInput | economiaCreateOrConnectWithoutPaisInput[]
    createMany?: economiaCreateManyPaisInputEnvelope
    connect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
  }

  export type ambienteCreateNestedManyWithoutPaisInput = {
    create?: XOR<ambienteCreateWithoutPaisInput, ambienteUncheckedCreateWithoutPaisInput> | ambienteCreateWithoutPaisInput[] | ambienteUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: ambienteCreateOrConnectWithoutPaisInput | ambienteCreateOrConnectWithoutPaisInput[]
    createMany?: ambienteCreateManyPaisInputEnvelope
    connect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
  }

  export type tecnologiaCreateNestedManyWithoutPaisInput = {
    create?: XOR<tecnologiaCreateWithoutPaisInput, tecnologiaUncheckedCreateWithoutPaisInput> | tecnologiaCreateWithoutPaisInput[] | tecnologiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: tecnologiaCreateOrConnectWithoutPaisInput | tecnologiaCreateOrConnectWithoutPaisInput[]
    createMany?: tecnologiaCreateManyPaisInputEnvelope
    connect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
  }

  export type demografiaCreateNestedManyWithoutPaisInput = {
    create?: XOR<demografiaCreateWithoutPaisInput, demografiaUncheckedCreateWithoutPaisInput> | demografiaCreateWithoutPaisInput[] | demografiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: demografiaCreateOrConnectWithoutPaisInput | demografiaCreateOrConnectWithoutPaisInput[]
    createMany?: demografiaCreateManyPaisInputEnvelope
    connect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
  }

  export type saudeUncheckedCreateNestedManyWithoutPaisInput = {
    create?: XOR<saudeCreateWithoutPaisInput, saudeUncheckedCreateWithoutPaisInput> | saudeCreateWithoutPaisInput[] | saudeUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: saudeCreateOrConnectWithoutPaisInput | saudeCreateOrConnectWithoutPaisInput[]
    createMany?: saudeCreateManyPaisInputEnvelope
    connect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
  }

  export type economiaUncheckedCreateNestedManyWithoutPaisInput = {
    create?: XOR<economiaCreateWithoutPaisInput, economiaUncheckedCreateWithoutPaisInput> | economiaCreateWithoutPaisInput[] | economiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: economiaCreateOrConnectWithoutPaisInput | economiaCreateOrConnectWithoutPaisInput[]
    createMany?: economiaCreateManyPaisInputEnvelope
    connect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
  }

  export type ambienteUncheckedCreateNestedManyWithoutPaisInput = {
    create?: XOR<ambienteCreateWithoutPaisInput, ambienteUncheckedCreateWithoutPaisInput> | ambienteCreateWithoutPaisInput[] | ambienteUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: ambienteCreateOrConnectWithoutPaisInput | ambienteCreateOrConnectWithoutPaisInput[]
    createMany?: ambienteCreateManyPaisInputEnvelope
    connect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
  }

  export type tecnologiaUncheckedCreateNestedManyWithoutPaisInput = {
    create?: XOR<tecnologiaCreateWithoutPaisInput, tecnologiaUncheckedCreateWithoutPaisInput> | tecnologiaCreateWithoutPaisInput[] | tecnologiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: tecnologiaCreateOrConnectWithoutPaisInput | tecnologiaCreateOrConnectWithoutPaisInput[]
    createMany?: tecnologiaCreateManyPaisInputEnvelope
    connect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
  }

  export type demografiaUncheckedCreateNestedManyWithoutPaisInput = {
    create?: XOR<demografiaCreateWithoutPaisInput, demografiaUncheckedCreateWithoutPaisInput> | demografiaCreateWithoutPaisInput[] | demografiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: demografiaCreateOrConnectWithoutPaisInput | demografiaCreateOrConnectWithoutPaisInput[]
    createMany?: demografiaCreateManyPaisInputEnvelope
    connect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type saudeUpdateManyWithoutPaisNestedInput = {
    create?: XOR<saudeCreateWithoutPaisInput, saudeUncheckedCreateWithoutPaisInput> | saudeCreateWithoutPaisInput[] | saudeUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: saudeCreateOrConnectWithoutPaisInput | saudeCreateOrConnectWithoutPaisInput[]
    upsert?: saudeUpsertWithWhereUniqueWithoutPaisInput | saudeUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: saudeCreateManyPaisInputEnvelope
    set?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    disconnect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    delete?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    connect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    update?: saudeUpdateWithWhereUniqueWithoutPaisInput | saudeUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: saudeUpdateManyWithWhereWithoutPaisInput | saudeUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: saudeScalarWhereInput | saudeScalarWhereInput[]
  }

  export type economiaUpdateManyWithoutPaisNestedInput = {
    create?: XOR<economiaCreateWithoutPaisInput, economiaUncheckedCreateWithoutPaisInput> | economiaCreateWithoutPaisInput[] | economiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: economiaCreateOrConnectWithoutPaisInput | economiaCreateOrConnectWithoutPaisInput[]
    upsert?: economiaUpsertWithWhereUniqueWithoutPaisInput | economiaUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: economiaCreateManyPaisInputEnvelope
    set?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    disconnect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    delete?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    connect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    update?: economiaUpdateWithWhereUniqueWithoutPaisInput | economiaUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: economiaUpdateManyWithWhereWithoutPaisInput | economiaUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: economiaScalarWhereInput | economiaScalarWhereInput[]
  }

  export type ambienteUpdateManyWithoutPaisNestedInput = {
    create?: XOR<ambienteCreateWithoutPaisInput, ambienteUncheckedCreateWithoutPaisInput> | ambienteCreateWithoutPaisInput[] | ambienteUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: ambienteCreateOrConnectWithoutPaisInput | ambienteCreateOrConnectWithoutPaisInput[]
    upsert?: ambienteUpsertWithWhereUniqueWithoutPaisInput | ambienteUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: ambienteCreateManyPaisInputEnvelope
    set?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    disconnect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    delete?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    connect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    update?: ambienteUpdateWithWhereUniqueWithoutPaisInput | ambienteUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: ambienteUpdateManyWithWhereWithoutPaisInput | ambienteUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: ambienteScalarWhereInput | ambienteScalarWhereInput[]
  }

  export type tecnologiaUpdateManyWithoutPaisNestedInput = {
    create?: XOR<tecnologiaCreateWithoutPaisInput, tecnologiaUncheckedCreateWithoutPaisInput> | tecnologiaCreateWithoutPaisInput[] | tecnologiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: tecnologiaCreateOrConnectWithoutPaisInput | tecnologiaCreateOrConnectWithoutPaisInput[]
    upsert?: tecnologiaUpsertWithWhereUniqueWithoutPaisInput | tecnologiaUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: tecnologiaCreateManyPaisInputEnvelope
    set?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    disconnect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    delete?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    connect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    update?: tecnologiaUpdateWithWhereUniqueWithoutPaisInput | tecnologiaUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: tecnologiaUpdateManyWithWhereWithoutPaisInput | tecnologiaUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: tecnologiaScalarWhereInput | tecnologiaScalarWhereInput[]
  }

  export type demografiaUpdateManyWithoutPaisNestedInput = {
    create?: XOR<demografiaCreateWithoutPaisInput, demografiaUncheckedCreateWithoutPaisInput> | demografiaCreateWithoutPaisInput[] | demografiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: demografiaCreateOrConnectWithoutPaisInput | demografiaCreateOrConnectWithoutPaisInput[]
    upsert?: demografiaUpsertWithWhereUniqueWithoutPaisInput | demografiaUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: demografiaCreateManyPaisInputEnvelope
    set?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    disconnect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    delete?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    connect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    update?: demografiaUpdateWithWhereUniqueWithoutPaisInput | demografiaUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: demografiaUpdateManyWithWhereWithoutPaisInput | demografiaUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: demografiaScalarWhereInput | demografiaScalarWhereInput[]
  }

  export type saudeUncheckedUpdateManyWithoutPaisNestedInput = {
    create?: XOR<saudeCreateWithoutPaisInput, saudeUncheckedCreateWithoutPaisInput> | saudeCreateWithoutPaisInput[] | saudeUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: saudeCreateOrConnectWithoutPaisInput | saudeCreateOrConnectWithoutPaisInput[]
    upsert?: saudeUpsertWithWhereUniqueWithoutPaisInput | saudeUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: saudeCreateManyPaisInputEnvelope
    set?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    disconnect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    delete?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    connect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    update?: saudeUpdateWithWhereUniqueWithoutPaisInput | saudeUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: saudeUpdateManyWithWhereWithoutPaisInput | saudeUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: saudeScalarWhereInput | saudeScalarWhereInput[]
  }

  export type economiaUncheckedUpdateManyWithoutPaisNestedInput = {
    create?: XOR<economiaCreateWithoutPaisInput, economiaUncheckedCreateWithoutPaisInput> | economiaCreateWithoutPaisInput[] | economiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: economiaCreateOrConnectWithoutPaisInput | economiaCreateOrConnectWithoutPaisInput[]
    upsert?: economiaUpsertWithWhereUniqueWithoutPaisInput | economiaUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: economiaCreateManyPaisInputEnvelope
    set?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    disconnect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    delete?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    connect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    update?: economiaUpdateWithWhereUniqueWithoutPaisInput | economiaUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: economiaUpdateManyWithWhereWithoutPaisInput | economiaUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: economiaScalarWhereInput | economiaScalarWhereInput[]
  }

  export type ambienteUncheckedUpdateManyWithoutPaisNestedInput = {
    create?: XOR<ambienteCreateWithoutPaisInput, ambienteUncheckedCreateWithoutPaisInput> | ambienteCreateWithoutPaisInput[] | ambienteUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: ambienteCreateOrConnectWithoutPaisInput | ambienteCreateOrConnectWithoutPaisInput[]
    upsert?: ambienteUpsertWithWhereUniqueWithoutPaisInput | ambienteUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: ambienteCreateManyPaisInputEnvelope
    set?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    disconnect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    delete?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    connect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    update?: ambienteUpdateWithWhereUniqueWithoutPaisInput | ambienteUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: ambienteUpdateManyWithWhereWithoutPaisInput | ambienteUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: ambienteScalarWhereInput | ambienteScalarWhereInput[]
  }

  export type tecnologiaUncheckedUpdateManyWithoutPaisNestedInput = {
    create?: XOR<tecnologiaCreateWithoutPaisInput, tecnologiaUncheckedCreateWithoutPaisInput> | tecnologiaCreateWithoutPaisInput[] | tecnologiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: tecnologiaCreateOrConnectWithoutPaisInput | tecnologiaCreateOrConnectWithoutPaisInput[]
    upsert?: tecnologiaUpsertWithWhereUniqueWithoutPaisInput | tecnologiaUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: tecnologiaCreateManyPaisInputEnvelope
    set?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    disconnect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    delete?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    connect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    update?: tecnologiaUpdateWithWhereUniqueWithoutPaisInput | tecnologiaUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: tecnologiaUpdateManyWithWhereWithoutPaisInput | tecnologiaUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: tecnologiaScalarWhereInput | tecnologiaScalarWhereInput[]
  }

  export type demografiaUncheckedUpdateManyWithoutPaisNestedInput = {
    create?: XOR<demografiaCreateWithoutPaisInput, demografiaUncheckedCreateWithoutPaisInput> | demografiaCreateWithoutPaisInput[] | demografiaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: demografiaCreateOrConnectWithoutPaisInput | demografiaCreateOrConnectWithoutPaisInput[]
    upsert?: demografiaUpsertWithWhereUniqueWithoutPaisInput | demografiaUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: demografiaCreateManyPaisInputEnvelope
    set?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    disconnect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    delete?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    connect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    update?: demografiaUpdateWithWhereUniqueWithoutPaisInput | demografiaUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: demografiaUpdateManyWithWhereWithoutPaisInput | demografiaUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: demografiaScalarWhereInput | demografiaScalarWhereInput[]
  }

  export type saudeCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<saudeCreateWithoutIndicadorInput, saudeUncheckedCreateWithoutIndicadorInput> | saudeCreateWithoutIndicadorInput[] | saudeUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: saudeCreateOrConnectWithoutIndicadorInput | saudeCreateOrConnectWithoutIndicadorInput[]
    createMany?: saudeCreateManyIndicadorInputEnvelope
    connect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
  }

  export type economiaCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<economiaCreateWithoutIndicadorInput, economiaUncheckedCreateWithoutIndicadorInput> | economiaCreateWithoutIndicadorInput[] | economiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: economiaCreateOrConnectWithoutIndicadorInput | economiaCreateOrConnectWithoutIndicadorInput[]
    createMany?: economiaCreateManyIndicadorInputEnvelope
    connect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
  }

  export type ambienteCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<ambienteCreateWithoutIndicadorInput, ambienteUncheckedCreateWithoutIndicadorInput> | ambienteCreateWithoutIndicadorInput[] | ambienteUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: ambienteCreateOrConnectWithoutIndicadorInput | ambienteCreateOrConnectWithoutIndicadorInput[]
    createMany?: ambienteCreateManyIndicadorInputEnvelope
    connect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
  }

  export type tecnologiaCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<tecnologiaCreateWithoutIndicadorInput, tecnologiaUncheckedCreateWithoutIndicadorInput> | tecnologiaCreateWithoutIndicadorInput[] | tecnologiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: tecnologiaCreateOrConnectWithoutIndicadorInput | tecnologiaCreateOrConnectWithoutIndicadorInput[]
    createMany?: tecnologiaCreateManyIndicadorInputEnvelope
    connect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
  }

  export type demografiaCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<demografiaCreateWithoutIndicadorInput, demografiaUncheckedCreateWithoutIndicadorInput> | demografiaCreateWithoutIndicadorInput[] | demografiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: demografiaCreateOrConnectWithoutIndicadorInput | demografiaCreateOrConnectWithoutIndicadorInput[]
    createMany?: demografiaCreateManyIndicadorInputEnvelope
    connect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
  }

  export type saudeUncheckedCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<saudeCreateWithoutIndicadorInput, saudeUncheckedCreateWithoutIndicadorInput> | saudeCreateWithoutIndicadorInput[] | saudeUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: saudeCreateOrConnectWithoutIndicadorInput | saudeCreateOrConnectWithoutIndicadorInput[]
    createMany?: saudeCreateManyIndicadorInputEnvelope
    connect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
  }

  export type economiaUncheckedCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<economiaCreateWithoutIndicadorInput, economiaUncheckedCreateWithoutIndicadorInput> | economiaCreateWithoutIndicadorInput[] | economiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: economiaCreateOrConnectWithoutIndicadorInput | economiaCreateOrConnectWithoutIndicadorInput[]
    createMany?: economiaCreateManyIndicadorInputEnvelope
    connect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
  }

  export type ambienteUncheckedCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<ambienteCreateWithoutIndicadorInput, ambienteUncheckedCreateWithoutIndicadorInput> | ambienteCreateWithoutIndicadorInput[] | ambienteUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: ambienteCreateOrConnectWithoutIndicadorInput | ambienteCreateOrConnectWithoutIndicadorInput[]
    createMany?: ambienteCreateManyIndicadorInputEnvelope
    connect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
  }

  export type tecnologiaUncheckedCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<tecnologiaCreateWithoutIndicadorInput, tecnologiaUncheckedCreateWithoutIndicadorInput> | tecnologiaCreateWithoutIndicadorInput[] | tecnologiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: tecnologiaCreateOrConnectWithoutIndicadorInput | tecnologiaCreateOrConnectWithoutIndicadorInput[]
    createMany?: tecnologiaCreateManyIndicadorInputEnvelope
    connect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
  }

  export type demografiaUncheckedCreateNestedManyWithoutIndicadorInput = {
    create?: XOR<demografiaCreateWithoutIndicadorInput, demografiaUncheckedCreateWithoutIndicadorInput> | demografiaCreateWithoutIndicadorInput[] | demografiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: demografiaCreateOrConnectWithoutIndicadorInput | demografiaCreateOrConnectWithoutIndicadorInput[]
    createMany?: demografiaCreateManyIndicadorInputEnvelope
    connect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
  }

  export type EnumcategoriaFieldUpdateOperationsInput = {
    set?: $Enums.categoria
  }

  export type saudeUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<saudeCreateWithoutIndicadorInput, saudeUncheckedCreateWithoutIndicadorInput> | saudeCreateWithoutIndicadorInput[] | saudeUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: saudeCreateOrConnectWithoutIndicadorInput | saudeCreateOrConnectWithoutIndicadorInput[]
    upsert?: saudeUpsertWithWhereUniqueWithoutIndicadorInput | saudeUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: saudeCreateManyIndicadorInputEnvelope
    set?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    disconnect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    delete?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    connect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    update?: saudeUpdateWithWhereUniqueWithoutIndicadorInput | saudeUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: saudeUpdateManyWithWhereWithoutIndicadorInput | saudeUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: saudeScalarWhereInput | saudeScalarWhereInput[]
  }

  export type economiaUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<economiaCreateWithoutIndicadorInput, economiaUncheckedCreateWithoutIndicadorInput> | economiaCreateWithoutIndicadorInput[] | economiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: economiaCreateOrConnectWithoutIndicadorInput | economiaCreateOrConnectWithoutIndicadorInput[]
    upsert?: economiaUpsertWithWhereUniqueWithoutIndicadorInput | economiaUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: economiaCreateManyIndicadorInputEnvelope
    set?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    disconnect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    delete?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    connect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    update?: economiaUpdateWithWhereUniqueWithoutIndicadorInput | economiaUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: economiaUpdateManyWithWhereWithoutIndicadorInput | economiaUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: economiaScalarWhereInput | economiaScalarWhereInput[]
  }

  export type ambienteUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<ambienteCreateWithoutIndicadorInput, ambienteUncheckedCreateWithoutIndicadorInput> | ambienteCreateWithoutIndicadorInput[] | ambienteUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: ambienteCreateOrConnectWithoutIndicadorInput | ambienteCreateOrConnectWithoutIndicadorInput[]
    upsert?: ambienteUpsertWithWhereUniqueWithoutIndicadorInput | ambienteUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: ambienteCreateManyIndicadorInputEnvelope
    set?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    disconnect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    delete?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    connect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    update?: ambienteUpdateWithWhereUniqueWithoutIndicadorInput | ambienteUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: ambienteUpdateManyWithWhereWithoutIndicadorInput | ambienteUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: ambienteScalarWhereInput | ambienteScalarWhereInput[]
  }

  export type tecnologiaUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<tecnologiaCreateWithoutIndicadorInput, tecnologiaUncheckedCreateWithoutIndicadorInput> | tecnologiaCreateWithoutIndicadorInput[] | tecnologiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: tecnologiaCreateOrConnectWithoutIndicadorInput | tecnologiaCreateOrConnectWithoutIndicadorInput[]
    upsert?: tecnologiaUpsertWithWhereUniqueWithoutIndicadorInput | tecnologiaUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: tecnologiaCreateManyIndicadorInputEnvelope
    set?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    disconnect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    delete?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    connect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    update?: tecnologiaUpdateWithWhereUniqueWithoutIndicadorInput | tecnologiaUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: tecnologiaUpdateManyWithWhereWithoutIndicadorInput | tecnologiaUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: tecnologiaScalarWhereInput | tecnologiaScalarWhereInput[]
  }

  export type demografiaUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<demografiaCreateWithoutIndicadorInput, demografiaUncheckedCreateWithoutIndicadorInput> | demografiaCreateWithoutIndicadorInput[] | demografiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: demografiaCreateOrConnectWithoutIndicadorInput | demografiaCreateOrConnectWithoutIndicadorInput[]
    upsert?: demografiaUpsertWithWhereUniqueWithoutIndicadorInput | demografiaUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: demografiaCreateManyIndicadorInputEnvelope
    set?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    disconnect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    delete?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    connect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    update?: demografiaUpdateWithWhereUniqueWithoutIndicadorInput | demografiaUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: demografiaUpdateManyWithWhereWithoutIndicadorInput | demografiaUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: demografiaScalarWhereInput | demografiaScalarWhereInput[]
  }

  export type saudeUncheckedUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<saudeCreateWithoutIndicadorInput, saudeUncheckedCreateWithoutIndicadorInput> | saudeCreateWithoutIndicadorInput[] | saudeUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: saudeCreateOrConnectWithoutIndicadorInput | saudeCreateOrConnectWithoutIndicadorInput[]
    upsert?: saudeUpsertWithWhereUniqueWithoutIndicadorInput | saudeUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: saudeCreateManyIndicadorInputEnvelope
    set?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    disconnect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    delete?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    connect?: saudeWhereUniqueInput | saudeWhereUniqueInput[]
    update?: saudeUpdateWithWhereUniqueWithoutIndicadorInput | saudeUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: saudeUpdateManyWithWhereWithoutIndicadorInput | saudeUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: saudeScalarWhereInput | saudeScalarWhereInput[]
  }

  export type economiaUncheckedUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<economiaCreateWithoutIndicadorInput, economiaUncheckedCreateWithoutIndicadorInput> | economiaCreateWithoutIndicadorInput[] | economiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: economiaCreateOrConnectWithoutIndicadorInput | economiaCreateOrConnectWithoutIndicadorInput[]
    upsert?: economiaUpsertWithWhereUniqueWithoutIndicadorInput | economiaUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: economiaCreateManyIndicadorInputEnvelope
    set?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    disconnect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    delete?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    connect?: economiaWhereUniqueInput | economiaWhereUniqueInput[]
    update?: economiaUpdateWithWhereUniqueWithoutIndicadorInput | economiaUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: economiaUpdateManyWithWhereWithoutIndicadorInput | economiaUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: economiaScalarWhereInput | economiaScalarWhereInput[]
  }

  export type ambienteUncheckedUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<ambienteCreateWithoutIndicadorInput, ambienteUncheckedCreateWithoutIndicadorInput> | ambienteCreateWithoutIndicadorInput[] | ambienteUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: ambienteCreateOrConnectWithoutIndicadorInput | ambienteCreateOrConnectWithoutIndicadorInput[]
    upsert?: ambienteUpsertWithWhereUniqueWithoutIndicadorInput | ambienteUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: ambienteCreateManyIndicadorInputEnvelope
    set?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    disconnect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    delete?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    connect?: ambienteWhereUniqueInput | ambienteWhereUniqueInput[]
    update?: ambienteUpdateWithWhereUniqueWithoutIndicadorInput | ambienteUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: ambienteUpdateManyWithWhereWithoutIndicadorInput | ambienteUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: ambienteScalarWhereInput | ambienteScalarWhereInput[]
  }

  export type tecnologiaUncheckedUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<tecnologiaCreateWithoutIndicadorInput, tecnologiaUncheckedCreateWithoutIndicadorInput> | tecnologiaCreateWithoutIndicadorInput[] | tecnologiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: tecnologiaCreateOrConnectWithoutIndicadorInput | tecnologiaCreateOrConnectWithoutIndicadorInput[]
    upsert?: tecnologiaUpsertWithWhereUniqueWithoutIndicadorInput | tecnologiaUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: tecnologiaCreateManyIndicadorInputEnvelope
    set?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    disconnect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    delete?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    connect?: tecnologiaWhereUniqueInput | tecnologiaWhereUniqueInput[]
    update?: tecnologiaUpdateWithWhereUniqueWithoutIndicadorInput | tecnologiaUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: tecnologiaUpdateManyWithWhereWithoutIndicadorInput | tecnologiaUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: tecnologiaScalarWhereInput | tecnologiaScalarWhereInput[]
  }

  export type demografiaUncheckedUpdateManyWithoutIndicadorNestedInput = {
    create?: XOR<demografiaCreateWithoutIndicadorInput, demografiaUncheckedCreateWithoutIndicadorInput> | demografiaCreateWithoutIndicadorInput[] | demografiaUncheckedCreateWithoutIndicadorInput[]
    connectOrCreate?: demografiaCreateOrConnectWithoutIndicadorInput | demografiaCreateOrConnectWithoutIndicadorInput[]
    upsert?: demografiaUpsertWithWhereUniqueWithoutIndicadorInput | demografiaUpsertWithWhereUniqueWithoutIndicadorInput[]
    createMany?: demografiaCreateManyIndicadorInputEnvelope
    set?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    disconnect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    delete?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    connect?: demografiaWhereUniqueInput | demografiaWhereUniqueInput[]
    update?: demografiaUpdateWithWhereUniqueWithoutIndicadorInput | demografiaUpdateWithWhereUniqueWithoutIndicadorInput[]
    updateMany?: demografiaUpdateManyWithWhereWithoutIndicadorInput | demografiaUpdateManyWithWhereWithoutIndicadorInput[]
    deleteMany?: demografiaScalarWhereInput | demografiaScalarWhereInput[]
  }

  export type paisCreateNestedOneWithoutSaudeInput = {
    create?: XOR<paisCreateWithoutSaudeInput, paisUncheckedCreateWithoutSaudeInput>
    connectOrCreate?: paisCreateOrConnectWithoutSaudeInput
    connect?: paisWhereUniqueInput
  }

  export type indicadorCreateNestedOneWithoutSaudeInput = {
    create?: XOR<indicadorCreateWithoutSaudeInput, indicadorUncheckedCreateWithoutSaudeInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutSaudeInput
    connect?: indicadorWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type paisUpdateOneRequiredWithoutSaudeNestedInput = {
    create?: XOR<paisCreateWithoutSaudeInput, paisUncheckedCreateWithoutSaudeInput>
    connectOrCreate?: paisCreateOrConnectWithoutSaudeInput
    upsert?: paisUpsertWithoutSaudeInput
    connect?: paisWhereUniqueInput
    update?: XOR<XOR<paisUpdateToOneWithWhereWithoutSaudeInput, paisUpdateWithoutSaudeInput>, paisUncheckedUpdateWithoutSaudeInput>
  }

  export type indicadorUpdateOneRequiredWithoutSaudeNestedInput = {
    create?: XOR<indicadorCreateWithoutSaudeInput, indicadorUncheckedCreateWithoutSaudeInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutSaudeInput
    upsert?: indicadorUpsertWithoutSaudeInput
    connect?: indicadorWhereUniqueInput
    update?: XOR<XOR<indicadorUpdateToOneWithWhereWithoutSaudeInput, indicadorUpdateWithoutSaudeInput>, indicadorUncheckedUpdateWithoutSaudeInput>
  }

  export type paisCreateNestedOneWithoutEconomiaInput = {
    create?: XOR<paisCreateWithoutEconomiaInput, paisUncheckedCreateWithoutEconomiaInput>
    connectOrCreate?: paisCreateOrConnectWithoutEconomiaInput
    connect?: paisWhereUniqueInput
  }

  export type indicadorCreateNestedOneWithoutEconomiaInput = {
    create?: XOR<indicadorCreateWithoutEconomiaInput, indicadorUncheckedCreateWithoutEconomiaInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutEconomiaInput
    connect?: indicadorWhereUniqueInput
  }

  export type paisUpdateOneRequiredWithoutEconomiaNestedInput = {
    create?: XOR<paisCreateWithoutEconomiaInput, paisUncheckedCreateWithoutEconomiaInput>
    connectOrCreate?: paisCreateOrConnectWithoutEconomiaInput
    upsert?: paisUpsertWithoutEconomiaInput
    connect?: paisWhereUniqueInput
    update?: XOR<XOR<paisUpdateToOneWithWhereWithoutEconomiaInput, paisUpdateWithoutEconomiaInput>, paisUncheckedUpdateWithoutEconomiaInput>
  }

  export type indicadorUpdateOneRequiredWithoutEconomiaNestedInput = {
    create?: XOR<indicadorCreateWithoutEconomiaInput, indicadorUncheckedCreateWithoutEconomiaInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutEconomiaInput
    upsert?: indicadorUpsertWithoutEconomiaInput
    connect?: indicadorWhereUniqueInput
    update?: XOR<XOR<indicadorUpdateToOneWithWhereWithoutEconomiaInput, indicadorUpdateWithoutEconomiaInput>, indicadorUncheckedUpdateWithoutEconomiaInput>
  }

  export type paisCreateNestedOneWithoutAmbienteInput = {
    create?: XOR<paisCreateWithoutAmbienteInput, paisUncheckedCreateWithoutAmbienteInput>
    connectOrCreate?: paisCreateOrConnectWithoutAmbienteInput
    connect?: paisWhereUniqueInput
  }

  export type indicadorCreateNestedOneWithoutAmbienteInput = {
    create?: XOR<indicadorCreateWithoutAmbienteInput, indicadorUncheckedCreateWithoutAmbienteInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutAmbienteInput
    connect?: indicadorWhereUniqueInput
  }

  export type paisUpdateOneRequiredWithoutAmbienteNestedInput = {
    create?: XOR<paisCreateWithoutAmbienteInput, paisUncheckedCreateWithoutAmbienteInput>
    connectOrCreate?: paisCreateOrConnectWithoutAmbienteInput
    upsert?: paisUpsertWithoutAmbienteInput
    connect?: paisWhereUniqueInput
    update?: XOR<XOR<paisUpdateToOneWithWhereWithoutAmbienteInput, paisUpdateWithoutAmbienteInput>, paisUncheckedUpdateWithoutAmbienteInput>
  }

  export type indicadorUpdateOneRequiredWithoutAmbienteNestedInput = {
    create?: XOR<indicadorCreateWithoutAmbienteInput, indicadorUncheckedCreateWithoutAmbienteInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutAmbienteInput
    upsert?: indicadorUpsertWithoutAmbienteInput
    connect?: indicadorWhereUniqueInput
    update?: XOR<XOR<indicadorUpdateToOneWithWhereWithoutAmbienteInput, indicadorUpdateWithoutAmbienteInput>, indicadorUncheckedUpdateWithoutAmbienteInput>
  }

  export type paisCreateNestedOneWithoutTecnologiaInput = {
    create?: XOR<paisCreateWithoutTecnologiaInput, paisUncheckedCreateWithoutTecnologiaInput>
    connectOrCreate?: paisCreateOrConnectWithoutTecnologiaInput
    connect?: paisWhereUniqueInput
  }

  export type indicadorCreateNestedOneWithoutTecnologiaInput = {
    create?: XOR<indicadorCreateWithoutTecnologiaInput, indicadorUncheckedCreateWithoutTecnologiaInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutTecnologiaInput
    connect?: indicadorWhereUniqueInput
  }

  export type paisUpdateOneRequiredWithoutTecnologiaNestedInput = {
    create?: XOR<paisCreateWithoutTecnologiaInput, paisUncheckedCreateWithoutTecnologiaInput>
    connectOrCreate?: paisCreateOrConnectWithoutTecnologiaInput
    upsert?: paisUpsertWithoutTecnologiaInput
    connect?: paisWhereUniqueInput
    update?: XOR<XOR<paisUpdateToOneWithWhereWithoutTecnologiaInput, paisUpdateWithoutTecnologiaInput>, paisUncheckedUpdateWithoutTecnologiaInput>
  }

  export type indicadorUpdateOneRequiredWithoutTecnologiaNestedInput = {
    create?: XOR<indicadorCreateWithoutTecnologiaInput, indicadorUncheckedCreateWithoutTecnologiaInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutTecnologiaInput
    upsert?: indicadorUpsertWithoutTecnologiaInput
    connect?: indicadorWhereUniqueInput
    update?: XOR<XOR<indicadorUpdateToOneWithWhereWithoutTecnologiaInput, indicadorUpdateWithoutTecnologiaInput>, indicadorUncheckedUpdateWithoutTecnologiaInput>
  }

  export type paisCreateNestedOneWithoutDemografiaInput = {
    create?: XOR<paisCreateWithoutDemografiaInput, paisUncheckedCreateWithoutDemografiaInput>
    connectOrCreate?: paisCreateOrConnectWithoutDemografiaInput
    connect?: paisWhereUniqueInput
  }

  export type indicadorCreateNestedOneWithoutDemografiaInput = {
    create?: XOR<indicadorCreateWithoutDemografiaInput, indicadorUncheckedCreateWithoutDemografiaInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutDemografiaInput
    connect?: indicadorWhereUniqueInput
  }

  export type paisUpdateOneRequiredWithoutDemografiaNestedInput = {
    create?: XOR<paisCreateWithoutDemografiaInput, paisUncheckedCreateWithoutDemografiaInput>
    connectOrCreate?: paisCreateOrConnectWithoutDemografiaInput
    upsert?: paisUpsertWithoutDemografiaInput
    connect?: paisWhereUniqueInput
    update?: XOR<XOR<paisUpdateToOneWithWhereWithoutDemografiaInput, paisUpdateWithoutDemografiaInput>, paisUncheckedUpdateWithoutDemografiaInput>
  }

  export type indicadorUpdateOneRequiredWithoutDemografiaNestedInput = {
    create?: XOR<indicadorCreateWithoutDemografiaInput, indicadorUncheckedCreateWithoutDemografiaInput>
    connectOrCreate?: indicadorCreateOrConnectWithoutDemografiaInput
    upsert?: indicadorUpsertWithoutDemografiaInput
    connect?: indicadorWhereUniqueInput
    update?: XOR<XOR<indicadorUpdateToOneWithWhereWithoutDemografiaInput, indicadorUpdateWithoutDemografiaInput>, indicadorUncheckedUpdateWithoutDemografiaInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumcategoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.categoria | EnumcategoriaFieldRefInput<$PrismaModel>
    in?: $Enums.categoria[] | ListEnumcategoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.categoria[] | ListEnumcategoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumcategoriaFilter<$PrismaModel> | $Enums.categoria
  }

  export type NestedEnumcategoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.categoria | EnumcategoriaFieldRefInput<$PrismaModel>
    in?: $Enums.categoria[] | ListEnumcategoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.categoria[] | ListEnumcategoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumcategoriaWithAggregatesFilter<$PrismaModel> | $Enums.categoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcategoriaFilter<$PrismaModel>
    _max?: NestedEnumcategoriaFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type saudeCreateWithoutPaisInput = {
    valor: number
    ano: number
    indicador: indicadorCreateNestedOneWithoutSaudeInput
  }

  export type saudeUncheckedCreateWithoutPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type saudeCreateOrConnectWithoutPaisInput = {
    where: saudeWhereUniqueInput
    create: XOR<saudeCreateWithoutPaisInput, saudeUncheckedCreateWithoutPaisInput>
  }

  export type saudeCreateManyPaisInputEnvelope = {
    data: saudeCreateManyPaisInput | saudeCreateManyPaisInput[]
    skipDuplicates?: boolean
  }

  export type economiaCreateWithoutPaisInput = {
    valor: number
    ano: number
    indicador: indicadorCreateNestedOneWithoutEconomiaInput
  }

  export type economiaUncheckedCreateWithoutPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type economiaCreateOrConnectWithoutPaisInput = {
    where: economiaWhereUniqueInput
    create: XOR<economiaCreateWithoutPaisInput, economiaUncheckedCreateWithoutPaisInput>
  }

  export type economiaCreateManyPaisInputEnvelope = {
    data: economiaCreateManyPaisInput | economiaCreateManyPaisInput[]
    skipDuplicates?: boolean
  }

  export type ambienteCreateWithoutPaisInput = {
    valor: number
    ano: number
    indicador: indicadorCreateNestedOneWithoutAmbienteInput
  }

  export type ambienteUncheckedCreateWithoutPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type ambienteCreateOrConnectWithoutPaisInput = {
    where: ambienteWhereUniqueInput
    create: XOR<ambienteCreateWithoutPaisInput, ambienteUncheckedCreateWithoutPaisInput>
  }

  export type ambienteCreateManyPaisInputEnvelope = {
    data: ambienteCreateManyPaisInput | ambienteCreateManyPaisInput[]
    skipDuplicates?: boolean
  }

  export type tecnologiaCreateWithoutPaisInput = {
    valor: number
    ano: number
    indicador: indicadorCreateNestedOneWithoutTecnologiaInput
  }

  export type tecnologiaUncheckedCreateWithoutPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type tecnologiaCreateOrConnectWithoutPaisInput = {
    where: tecnologiaWhereUniqueInput
    create: XOR<tecnologiaCreateWithoutPaisInput, tecnologiaUncheckedCreateWithoutPaisInput>
  }

  export type tecnologiaCreateManyPaisInputEnvelope = {
    data: tecnologiaCreateManyPaisInput | tecnologiaCreateManyPaisInput[]
    skipDuplicates?: boolean
  }

  export type demografiaCreateWithoutPaisInput = {
    valor: number
    ano: number
    indicador: indicadorCreateNestedOneWithoutDemografiaInput
  }

  export type demografiaUncheckedCreateWithoutPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type demografiaCreateOrConnectWithoutPaisInput = {
    where: demografiaWhereUniqueInput
    create: XOR<demografiaCreateWithoutPaisInput, demografiaUncheckedCreateWithoutPaisInput>
  }

  export type demografiaCreateManyPaisInputEnvelope = {
    data: demografiaCreateManyPaisInput | demografiaCreateManyPaisInput[]
    skipDuplicates?: boolean
  }

  export type saudeUpsertWithWhereUniqueWithoutPaisInput = {
    where: saudeWhereUniqueInput
    update: XOR<saudeUpdateWithoutPaisInput, saudeUncheckedUpdateWithoutPaisInput>
    create: XOR<saudeCreateWithoutPaisInput, saudeUncheckedCreateWithoutPaisInput>
  }

  export type saudeUpdateWithWhereUniqueWithoutPaisInput = {
    where: saudeWhereUniqueInput
    data: XOR<saudeUpdateWithoutPaisInput, saudeUncheckedUpdateWithoutPaisInput>
  }

  export type saudeUpdateManyWithWhereWithoutPaisInput = {
    where: saudeScalarWhereInput
    data: XOR<saudeUpdateManyMutationInput, saudeUncheckedUpdateManyWithoutPaisInput>
  }

  export type saudeScalarWhereInput = {
    AND?: saudeScalarWhereInput | saudeScalarWhereInput[]
    OR?: saudeScalarWhereInput[]
    NOT?: saudeScalarWhereInput | saudeScalarWhereInput[]
    id?: IntFilter<"saude"> | number
    valor?: FloatFilter<"saude"> | number
    ano?: IntFilter<"saude"> | number
    pais_id?: StringFilter<"saude"> | string
    indicador_id?: StringFilter<"saude"> | string
  }

  export type economiaUpsertWithWhereUniqueWithoutPaisInput = {
    where: economiaWhereUniqueInput
    update: XOR<economiaUpdateWithoutPaisInput, economiaUncheckedUpdateWithoutPaisInput>
    create: XOR<economiaCreateWithoutPaisInput, economiaUncheckedCreateWithoutPaisInput>
  }

  export type economiaUpdateWithWhereUniqueWithoutPaisInput = {
    where: economiaWhereUniqueInput
    data: XOR<economiaUpdateWithoutPaisInput, economiaUncheckedUpdateWithoutPaisInput>
  }

  export type economiaUpdateManyWithWhereWithoutPaisInput = {
    where: economiaScalarWhereInput
    data: XOR<economiaUpdateManyMutationInput, economiaUncheckedUpdateManyWithoutPaisInput>
  }

  export type economiaScalarWhereInput = {
    AND?: economiaScalarWhereInput | economiaScalarWhereInput[]
    OR?: economiaScalarWhereInput[]
    NOT?: economiaScalarWhereInput | economiaScalarWhereInput[]
    id?: IntFilter<"economia"> | number
    valor?: FloatFilter<"economia"> | number
    ano?: IntFilter<"economia"> | number
    pais_id?: StringFilter<"economia"> | string
    indicador_id?: StringFilter<"economia"> | string
  }

  export type ambienteUpsertWithWhereUniqueWithoutPaisInput = {
    where: ambienteWhereUniqueInput
    update: XOR<ambienteUpdateWithoutPaisInput, ambienteUncheckedUpdateWithoutPaisInput>
    create: XOR<ambienteCreateWithoutPaisInput, ambienteUncheckedCreateWithoutPaisInput>
  }

  export type ambienteUpdateWithWhereUniqueWithoutPaisInput = {
    where: ambienteWhereUniqueInput
    data: XOR<ambienteUpdateWithoutPaisInput, ambienteUncheckedUpdateWithoutPaisInput>
  }

  export type ambienteUpdateManyWithWhereWithoutPaisInput = {
    where: ambienteScalarWhereInput
    data: XOR<ambienteUpdateManyMutationInput, ambienteUncheckedUpdateManyWithoutPaisInput>
  }

  export type ambienteScalarWhereInput = {
    AND?: ambienteScalarWhereInput | ambienteScalarWhereInput[]
    OR?: ambienteScalarWhereInput[]
    NOT?: ambienteScalarWhereInput | ambienteScalarWhereInput[]
    id?: IntFilter<"ambiente"> | number
    valor?: FloatFilter<"ambiente"> | number
    ano?: IntFilter<"ambiente"> | number
    pais_id?: StringFilter<"ambiente"> | string
    indicador_id?: StringFilter<"ambiente"> | string
  }

  export type tecnologiaUpsertWithWhereUniqueWithoutPaisInput = {
    where: tecnologiaWhereUniqueInput
    update: XOR<tecnologiaUpdateWithoutPaisInput, tecnologiaUncheckedUpdateWithoutPaisInput>
    create: XOR<tecnologiaCreateWithoutPaisInput, tecnologiaUncheckedCreateWithoutPaisInput>
  }

  export type tecnologiaUpdateWithWhereUniqueWithoutPaisInput = {
    where: tecnologiaWhereUniqueInput
    data: XOR<tecnologiaUpdateWithoutPaisInput, tecnologiaUncheckedUpdateWithoutPaisInput>
  }

  export type tecnologiaUpdateManyWithWhereWithoutPaisInput = {
    where: tecnologiaScalarWhereInput
    data: XOR<tecnologiaUpdateManyMutationInput, tecnologiaUncheckedUpdateManyWithoutPaisInput>
  }

  export type tecnologiaScalarWhereInput = {
    AND?: tecnologiaScalarWhereInput | tecnologiaScalarWhereInput[]
    OR?: tecnologiaScalarWhereInput[]
    NOT?: tecnologiaScalarWhereInput | tecnologiaScalarWhereInput[]
    id?: IntFilter<"tecnologia"> | number
    valor?: FloatFilter<"tecnologia"> | number
    ano?: IntFilter<"tecnologia"> | number
    pais_id?: StringFilter<"tecnologia"> | string
    indicador_id?: StringFilter<"tecnologia"> | string
  }

  export type demografiaUpsertWithWhereUniqueWithoutPaisInput = {
    where: demografiaWhereUniqueInput
    update: XOR<demografiaUpdateWithoutPaisInput, demografiaUncheckedUpdateWithoutPaisInput>
    create: XOR<demografiaCreateWithoutPaisInput, demografiaUncheckedCreateWithoutPaisInput>
  }

  export type demografiaUpdateWithWhereUniqueWithoutPaisInput = {
    where: demografiaWhereUniqueInput
    data: XOR<demografiaUpdateWithoutPaisInput, demografiaUncheckedUpdateWithoutPaisInput>
  }

  export type demografiaUpdateManyWithWhereWithoutPaisInput = {
    where: demografiaScalarWhereInput
    data: XOR<demografiaUpdateManyMutationInput, demografiaUncheckedUpdateManyWithoutPaisInput>
  }

  export type demografiaScalarWhereInput = {
    AND?: demografiaScalarWhereInput | demografiaScalarWhereInput[]
    OR?: demografiaScalarWhereInput[]
    NOT?: demografiaScalarWhereInput | demografiaScalarWhereInput[]
    id?: IntFilter<"demografia"> | number
    valor?: FloatFilter<"demografia"> | number
    ano?: IntFilter<"demografia"> | number
    pais_id?: StringFilter<"demografia"> | string
    indicador_id?: StringFilter<"demografia"> | string
  }

  export type saudeCreateWithoutIndicadorInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutSaudeInput
  }

  export type saudeUncheckedCreateWithoutIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type saudeCreateOrConnectWithoutIndicadorInput = {
    where: saudeWhereUniqueInput
    create: XOR<saudeCreateWithoutIndicadorInput, saudeUncheckedCreateWithoutIndicadorInput>
  }

  export type saudeCreateManyIndicadorInputEnvelope = {
    data: saudeCreateManyIndicadorInput | saudeCreateManyIndicadorInput[]
    skipDuplicates?: boolean
  }

  export type economiaCreateWithoutIndicadorInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutEconomiaInput
  }

  export type economiaUncheckedCreateWithoutIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type economiaCreateOrConnectWithoutIndicadorInput = {
    where: economiaWhereUniqueInput
    create: XOR<economiaCreateWithoutIndicadorInput, economiaUncheckedCreateWithoutIndicadorInput>
  }

  export type economiaCreateManyIndicadorInputEnvelope = {
    data: economiaCreateManyIndicadorInput | economiaCreateManyIndicadorInput[]
    skipDuplicates?: boolean
  }

  export type ambienteCreateWithoutIndicadorInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutAmbienteInput
  }

  export type ambienteUncheckedCreateWithoutIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type ambienteCreateOrConnectWithoutIndicadorInput = {
    where: ambienteWhereUniqueInput
    create: XOR<ambienteCreateWithoutIndicadorInput, ambienteUncheckedCreateWithoutIndicadorInput>
  }

  export type ambienteCreateManyIndicadorInputEnvelope = {
    data: ambienteCreateManyIndicadorInput | ambienteCreateManyIndicadorInput[]
    skipDuplicates?: boolean
  }

  export type tecnologiaCreateWithoutIndicadorInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutTecnologiaInput
  }

  export type tecnologiaUncheckedCreateWithoutIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type tecnologiaCreateOrConnectWithoutIndicadorInput = {
    where: tecnologiaWhereUniqueInput
    create: XOR<tecnologiaCreateWithoutIndicadorInput, tecnologiaUncheckedCreateWithoutIndicadorInput>
  }

  export type tecnologiaCreateManyIndicadorInputEnvelope = {
    data: tecnologiaCreateManyIndicadorInput | tecnologiaCreateManyIndicadorInput[]
    skipDuplicates?: boolean
  }

  export type demografiaCreateWithoutIndicadorInput = {
    valor: number
    ano: number
    pais: paisCreateNestedOneWithoutDemografiaInput
  }

  export type demografiaUncheckedCreateWithoutIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type demografiaCreateOrConnectWithoutIndicadorInput = {
    where: demografiaWhereUniqueInput
    create: XOR<demografiaCreateWithoutIndicadorInput, demografiaUncheckedCreateWithoutIndicadorInput>
  }

  export type demografiaCreateManyIndicadorInputEnvelope = {
    data: demografiaCreateManyIndicadorInput | demografiaCreateManyIndicadorInput[]
    skipDuplicates?: boolean
  }

  export type saudeUpsertWithWhereUniqueWithoutIndicadorInput = {
    where: saudeWhereUniqueInput
    update: XOR<saudeUpdateWithoutIndicadorInput, saudeUncheckedUpdateWithoutIndicadorInput>
    create: XOR<saudeCreateWithoutIndicadorInput, saudeUncheckedCreateWithoutIndicadorInput>
  }

  export type saudeUpdateWithWhereUniqueWithoutIndicadorInput = {
    where: saudeWhereUniqueInput
    data: XOR<saudeUpdateWithoutIndicadorInput, saudeUncheckedUpdateWithoutIndicadorInput>
  }

  export type saudeUpdateManyWithWhereWithoutIndicadorInput = {
    where: saudeScalarWhereInput
    data: XOR<saudeUpdateManyMutationInput, saudeUncheckedUpdateManyWithoutIndicadorInput>
  }

  export type economiaUpsertWithWhereUniqueWithoutIndicadorInput = {
    where: economiaWhereUniqueInput
    update: XOR<economiaUpdateWithoutIndicadorInput, economiaUncheckedUpdateWithoutIndicadorInput>
    create: XOR<economiaCreateWithoutIndicadorInput, economiaUncheckedCreateWithoutIndicadorInput>
  }

  export type economiaUpdateWithWhereUniqueWithoutIndicadorInput = {
    where: economiaWhereUniqueInput
    data: XOR<economiaUpdateWithoutIndicadorInput, economiaUncheckedUpdateWithoutIndicadorInput>
  }

  export type economiaUpdateManyWithWhereWithoutIndicadorInput = {
    where: economiaScalarWhereInput
    data: XOR<economiaUpdateManyMutationInput, economiaUncheckedUpdateManyWithoutIndicadorInput>
  }

  export type ambienteUpsertWithWhereUniqueWithoutIndicadorInput = {
    where: ambienteWhereUniqueInput
    update: XOR<ambienteUpdateWithoutIndicadorInput, ambienteUncheckedUpdateWithoutIndicadorInput>
    create: XOR<ambienteCreateWithoutIndicadorInput, ambienteUncheckedCreateWithoutIndicadorInput>
  }

  export type ambienteUpdateWithWhereUniqueWithoutIndicadorInput = {
    where: ambienteWhereUniqueInput
    data: XOR<ambienteUpdateWithoutIndicadorInput, ambienteUncheckedUpdateWithoutIndicadorInput>
  }

  export type ambienteUpdateManyWithWhereWithoutIndicadorInput = {
    where: ambienteScalarWhereInput
    data: XOR<ambienteUpdateManyMutationInput, ambienteUncheckedUpdateManyWithoutIndicadorInput>
  }

  export type tecnologiaUpsertWithWhereUniqueWithoutIndicadorInput = {
    where: tecnologiaWhereUniqueInput
    update: XOR<tecnologiaUpdateWithoutIndicadorInput, tecnologiaUncheckedUpdateWithoutIndicadorInput>
    create: XOR<tecnologiaCreateWithoutIndicadorInput, tecnologiaUncheckedCreateWithoutIndicadorInput>
  }

  export type tecnologiaUpdateWithWhereUniqueWithoutIndicadorInput = {
    where: tecnologiaWhereUniqueInput
    data: XOR<tecnologiaUpdateWithoutIndicadorInput, tecnologiaUncheckedUpdateWithoutIndicadorInput>
  }

  export type tecnologiaUpdateManyWithWhereWithoutIndicadorInput = {
    where: tecnologiaScalarWhereInput
    data: XOR<tecnologiaUpdateManyMutationInput, tecnologiaUncheckedUpdateManyWithoutIndicadorInput>
  }

  export type demografiaUpsertWithWhereUniqueWithoutIndicadorInput = {
    where: demografiaWhereUniqueInput
    update: XOR<demografiaUpdateWithoutIndicadorInput, demografiaUncheckedUpdateWithoutIndicadorInput>
    create: XOR<demografiaCreateWithoutIndicadorInput, demografiaUncheckedCreateWithoutIndicadorInput>
  }

  export type demografiaUpdateWithWhereUniqueWithoutIndicadorInput = {
    where: demografiaWhereUniqueInput
    data: XOR<demografiaUpdateWithoutIndicadorInput, demografiaUncheckedUpdateWithoutIndicadorInput>
  }

  export type demografiaUpdateManyWithWhereWithoutIndicadorInput = {
    where: demografiaScalarWhereInput
    data: XOR<demografiaUpdateManyMutationInput, demografiaUncheckedUpdateManyWithoutIndicadorInput>
  }

  export type paisCreateWithoutSaudeInput = {
    id: string
    nome: string
    iso3: string
    economia?: economiaCreateNestedManyWithoutPaisInput
    ambiente?: ambienteCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaCreateNestedManyWithoutPaisInput
    demografia?: demografiaCreateNestedManyWithoutPaisInput
  }

  export type paisUncheckedCreateWithoutSaudeInput = {
    id: string
    nome: string
    iso3: string
    economia?: economiaUncheckedCreateNestedManyWithoutPaisInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutPaisInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutPaisInput
  }

  export type paisCreateOrConnectWithoutSaudeInput = {
    where: paisWhereUniqueInput
    create: XOR<paisCreateWithoutSaudeInput, paisUncheckedCreateWithoutSaudeInput>
  }

  export type indicadorCreateWithoutSaudeInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    economia?: economiaCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorUncheckedCreateWithoutSaudeInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    economia?: economiaUncheckedCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorCreateOrConnectWithoutSaudeInput = {
    where: indicadorWhereUniqueInput
    create: XOR<indicadorCreateWithoutSaudeInput, indicadorUncheckedCreateWithoutSaudeInput>
  }

  export type paisUpsertWithoutSaudeInput = {
    update: XOR<paisUpdateWithoutSaudeInput, paisUncheckedUpdateWithoutSaudeInput>
    create: XOR<paisCreateWithoutSaudeInput, paisUncheckedCreateWithoutSaudeInput>
    where?: paisWhereInput
  }

  export type paisUpdateToOneWithWhereWithoutSaudeInput = {
    where?: paisWhereInput
    data: XOR<paisUpdateWithoutSaudeInput, paisUncheckedUpdateWithoutSaudeInput>
  }

  export type paisUpdateWithoutSaudeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    economia?: economiaUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUpdateManyWithoutPaisNestedInput
  }

  export type paisUncheckedUpdateWithoutSaudeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    economia?: economiaUncheckedUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutPaisNestedInput
  }

  export type indicadorUpsertWithoutSaudeInput = {
    update: XOR<indicadorUpdateWithoutSaudeInput, indicadorUncheckedUpdateWithoutSaudeInput>
    create: XOR<indicadorCreateWithoutSaudeInput, indicadorUncheckedCreateWithoutSaudeInput>
    where?: indicadorWhereInput
  }

  export type indicadorUpdateToOneWithWhereWithoutSaudeInput = {
    where?: indicadorWhereInput
    data: XOR<indicadorUpdateWithoutSaudeInput, indicadorUncheckedUpdateWithoutSaudeInput>
  }

  export type indicadorUpdateWithoutSaudeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    economia?: economiaUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUpdateManyWithoutIndicadorNestedInput
  }

  export type indicadorUncheckedUpdateWithoutSaudeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    economia?: economiaUncheckedUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutIndicadorNestedInput
  }

  export type paisCreateWithoutEconomiaInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeCreateNestedManyWithoutPaisInput
    ambiente?: ambienteCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaCreateNestedManyWithoutPaisInput
    demografia?: demografiaCreateNestedManyWithoutPaisInput
  }

  export type paisUncheckedCreateWithoutEconomiaInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeUncheckedCreateNestedManyWithoutPaisInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutPaisInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutPaisInput
  }

  export type paisCreateOrConnectWithoutEconomiaInput = {
    where: paisWhereUniqueInput
    create: XOR<paisCreateWithoutEconomiaInput, paisUncheckedCreateWithoutEconomiaInput>
  }

  export type indicadorCreateWithoutEconomiaInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorUncheckedCreateWithoutEconomiaInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeUncheckedCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorCreateOrConnectWithoutEconomiaInput = {
    where: indicadorWhereUniqueInput
    create: XOR<indicadorCreateWithoutEconomiaInput, indicadorUncheckedCreateWithoutEconomiaInput>
  }

  export type paisUpsertWithoutEconomiaInput = {
    update: XOR<paisUpdateWithoutEconomiaInput, paisUncheckedUpdateWithoutEconomiaInput>
    create: XOR<paisCreateWithoutEconomiaInput, paisUncheckedCreateWithoutEconomiaInput>
    where?: paisWhereInput
  }

  export type paisUpdateToOneWithWhereWithoutEconomiaInput = {
    where?: paisWhereInput
    data: XOR<paisUpdateWithoutEconomiaInput, paisUncheckedUpdateWithoutEconomiaInput>
  }

  export type paisUpdateWithoutEconomiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUpdateManyWithoutPaisNestedInput
  }

  export type paisUncheckedUpdateWithoutEconomiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUncheckedUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutPaisNestedInput
  }

  export type indicadorUpsertWithoutEconomiaInput = {
    update: XOR<indicadorUpdateWithoutEconomiaInput, indicadorUncheckedUpdateWithoutEconomiaInput>
    create: XOR<indicadorCreateWithoutEconomiaInput, indicadorUncheckedCreateWithoutEconomiaInput>
    where?: indicadorWhereInput
  }

  export type indicadorUpdateToOneWithWhereWithoutEconomiaInput = {
    where?: indicadorWhereInput
    data: XOR<indicadorUpdateWithoutEconomiaInput, indicadorUncheckedUpdateWithoutEconomiaInput>
  }

  export type indicadorUpdateWithoutEconomiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUpdateManyWithoutIndicadorNestedInput
  }

  export type indicadorUncheckedUpdateWithoutEconomiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUncheckedUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutIndicadorNestedInput
  }

  export type paisCreateWithoutAmbienteInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeCreateNestedManyWithoutPaisInput
    economia?: economiaCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaCreateNestedManyWithoutPaisInput
    demografia?: demografiaCreateNestedManyWithoutPaisInput
  }

  export type paisUncheckedCreateWithoutAmbienteInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeUncheckedCreateNestedManyWithoutPaisInput
    economia?: economiaUncheckedCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutPaisInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutPaisInput
  }

  export type paisCreateOrConnectWithoutAmbienteInput = {
    where: paisWhereUniqueInput
    create: XOR<paisCreateWithoutAmbienteInput, paisUncheckedCreateWithoutAmbienteInput>
  }

  export type indicadorCreateWithoutAmbienteInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeCreateNestedManyWithoutIndicadorInput
    economia?: economiaCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorUncheckedCreateWithoutAmbienteInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeUncheckedCreateNestedManyWithoutIndicadorInput
    economia?: economiaUncheckedCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorCreateOrConnectWithoutAmbienteInput = {
    where: indicadorWhereUniqueInput
    create: XOR<indicadorCreateWithoutAmbienteInput, indicadorUncheckedCreateWithoutAmbienteInput>
  }

  export type paisUpsertWithoutAmbienteInput = {
    update: XOR<paisUpdateWithoutAmbienteInput, paisUncheckedUpdateWithoutAmbienteInput>
    create: XOR<paisCreateWithoutAmbienteInput, paisUncheckedCreateWithoutAmbienteInput>
    where?: paisWhereInput
  }

  export type paisUpdateToOneWithWhereWithoutAmbienteInput = {
    where?: paisWhereInput
    data: XOR<paisUpdateWithoutAmbienteInput, paisUncheckedUpdateWithoutAmbienteInput>
  }

  export type paisUpdateWithoutAmbienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUpdateManyWithoutPaisNestedInput
    economia?: economiaUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUpdateManyWithoutPaisNestedInput
  }

  export type paisUncheckedUpdateWithoutAmbienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUncheckedUpdateManyWithoutPaisNestedInput
    economia?: economiaUncheckedUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutPaisNestedInput
  }

  export type indicadorUpsertWithoutAmbienteInput = {
    update: XOR<indicadorUpdateWithoutAmbienteInput, indicadorUncheckedUpdateWithoutAmbienteInput>
    create: XOR<indicadorCreateWithoutAmbienteInput, indicadorUncheckedCreateWithoutAmbienteInput>
    where?: indicadorWhereInput
  }

  export type indicadorUpdateToOneWithWhereWithoutAmbienteInput = {
    where?: indicadorWhereInput
    data: XOR<indicadorUpdateWithoutAmbienteInput, indicadorUncheckedUpdateWithoutAmbienteInput>
  }

  export type indicadorUpdateWithoutAmbienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUpdateManyWithoutIndicadorNestedInput
    economia?: economiaUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUpdateManyWithoutIndicadorNestedInput
  }

  export type indicadorUncheckedUpdateWithoutAmbienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUncheckedUpdateManyWithoutIndicadorNestedInput
    economia?: economiaUncheckedUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutIndicadorNestedInput
  }

  export type paisCreateWithoutTecnologiaInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeCreateNestedManyWithoutPaisInput
    economia?: economiaCreateNestedManyWithoutPaisInput
    ambiente?: ambienteCreateNestedManyWithoutPaisInput
    demografia?: demografiaCreateNestedManyWithoutPaisInput
  }

  export type paisUncheckedCreateWithoutTecnologiaInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeUncheckedCreateNestedManyWithoutPaisInput
    economia?: economiaUncheckedCreateNestedManyWithoutPaisInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutPaisInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutPaisInput
  }

  export type paisCreateOrConnectWithoutTecnologiaInput = {
    where: paisWhereUniqueInput
    create: XOR<paisCreateWithoutTecnologiaInput, paisUncheckedCreateWithoutTecnologiaInput>
  }

  export type indicadorCreateWithoutTecnologiaInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeCreateNestedManyWithoutIndicadorInput
    economia?: economiaCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorUncheckedCreateWithoutTecnologiaInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeUncheckedCreateNestedManyWithoutIndicadorInput
    economia?: economiaUncheckedCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutIndicadorInput
    demografia?: demografiaUncheckedCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorCreateOrConnectWithoutTecnologiaInput = {
    where: indicadorWhereUniqueInput
    create: XOR<indicadorCreateWithoutTecnologiaInput, indicadorUncheckedCreateWithoutTecnologiaInput>
  }

  export type paisUpsertWithoutTecnologiaInput = {
    update: XOR<paisUpdateWithoutTecnologiaInput, paisUncheckedUpdateWithoutTecnologiaInput>
    create: XOR<paisCreateWithoutTecnologiaInput, paisUncheckedCreateWithoutTecnologiaInput>
    where?: paisWhereInput
  }

  export type paisUpdateToOneWithWhereWithoutTecnologiaInput = {
    where?: paisWhereInput
    data: XOR<paisUpdateWithoutTecnologiaInput, paisUncheckedUpdateWithoutTecnologiaInput>
  }

  export type paisUpdateWithoutTecnologiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUpdateManyWithoutPaisNestedInput
    economia?: economiaUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUpdateManyWithoutPaisNestedInput
  }

  export type paisUncheckedUpdateWithoutTecnologiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUncheckedUpdateManyWithoutPaisNestedInput
    economia?: economiaUncheckedUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutPaisNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutPaisNestedInput
  }

  export type indicadorUpsertWithoutTecnologiaInput = {
    update: XOR<indicadorUpdateWithoutTecnologiaInput, indicadorUncheckedUpdateWithoutTecnologiaInput>
    create: XOR<indicadorCreateWithoutTecnologiaInput, indicadorUncheckedCreateWithoutTecnologiaInput>
    where?: indicadorWhereInput
  }

  export type indicadorUpdateToOneWithWhereWithoutTecnologiaInput = {
    where?: indicadorWhereInput
    data: XOR<indicadorUpdateWithoutTecnologiaInput, indicadorUncheckedUpdateWithoutTecnologiaInput>
  }

  export type indicadorUpdateWithoutTecnologiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUpdateManyWithoutIndicadorNestedInput
    economia?: economiaUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUpdateManyWithoutIndicadorNestedInput
  }

  export type indicadorUncheckedUpdateWithoutTecnologiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUncheckedUpdateManyWithoutIndicadorNestedInput
    economia?: economiaUncheckedUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutIndicadorNestedInput
    demografia?: demografiaUncheckedUpdateManyWithoutIndicadorNestedInput
  }

  export type paisCreateWithoutDemografiaInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeCreateNestedManyWithoutPaisInput
    economia?: economiaCreateNestedManyWithoutPaisInput
    ambiente?: ambienteCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaCreateNestedManyWithoutPaisInput
  }

  export type paisUncheckedCreateWithoutDemografiaInput = {
    id: string
    nome: string
    iso3: string
    saude?: saudeUncheckedCreateNestedManyWithoutPaisInput
    economia?: economiaUncheckedCreateNestedManyWithoutPaisInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutPaisInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutPaisInput
  }

  export type paisCreateOrConnectWithoutDemografiaInput = {
    where: paisWhereUniqueInput
    create: XOR<paisCreateWithoutDemografiaInput, paisUncheckedCreateWithoutDemografiaInput>
  }

  export type indicadorCreateWithoutDemografiaInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeCreateNestedManyWithoutIndicadorInput
    economia?: economiaCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorUncheckedCreateWithoutDemografiaInput = {
    id: string
    nome: string
    categoria: $Enums.categoria
    saude?: saudeUncheckedCreateNestedManyWithoutIndicadorInput
    economia?: economiaUncheckedCreateNestedManyWithoutIndicadorInput
    ambiente?: ambienteUncheckedCreateNestedManyWithoutIndicadorInput
    tecnologia?: tecnologiaUncheckedCreateNestedManyWithoutIndicadorInput
  }

  export type indicadorCreateOrConnectWithoutDemografiaInput = {
    where: indicadorWhereUniqueInput
    create: XOR<indicadorCreateWithoutDemografiaInput, indicadorUncheckedCreateWithoutDemografiaInput>
  }

  export type paisUpsertWithoutDemografiaInput = {
    update: XOR<paisUpdateWithoutDemografiaInput, paisUncheckedUpdateWithoutDemografiaInput>
    create: XOR<paisCreateWithoutDemografiaInput, paisUncheckedCreateWithoutDemografiaInput>
    where?: paisWhereInput
  }

  export type paisUpdateToOneWithWhereWithoutDemografiaInput = {
    where?: paisWhereInput
    data: XOR<paisUpdateWithoutDemografiaInput, paisUncheckedUpdateWithoutDemografiaInput>
  }

  export type paisUpdateWithoutDemografiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUpdateManyWithoutPaisNestedInput
    economia?: economiaUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutPaisNestedInput
  }

  export type paisUncheckedUpdateWithoutDemografiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    iso3?: StringFieldUpdateOperationsInput | string
    saude?: saudeUncheckedUpdateManyWithoutPaisNestedInput
    economia?: economiaUncheckedUpdateManyWithoutPaisNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutPaisNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutPaisNestedInput
  }

  export type indicadorUpsertWithoutDemografiaInput = {
    update: XOR<indicadorUpdateWithoutDemografiaInput, indicadorUncheckedUpdateWithoutDemografiaInput>
    create: XOR<indicadorCreateWithoutDemografiaInput, indicadorUncheckedCreateWithoutDemografiaInput>
    where?: indicadorWhereInput
  }

  export type indicadorUpdateToOneWithWhereWithoutDemografiaInput = {
    where?: indicadorWhereInput
    data: XOR<indicadorUpdateWithoutDemografiaInput, indicadorUncheckedUpdateWithoutDemografiaInput>
  }

  export type indicadorUpdateWithoutDemografiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUpdateManyWithoutIndicadorNestedInput
    economia?: economiaUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUpdateManyWithoutIndicadorNestedInput
  }

  export type indicadorUncheckedUpdateWithoutDemografiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    categoria?: EnumcategoriaFieldUpdateOperationsInput | $Enums.categoria
    saude?: saudeUncheckedUpdateManyWithoutIndicadorNestedInput
    economia?: economiaUncheckedUpdateManyWithoutIndicadorNestedInput
    ambiente?: ambienteUncheckedUpdateManyWithoutIndicadorNestedInput
    tecnologia?: tecnologiaUncheckedUpdateManyWithoutIndicadorNestedInput
  }

  export type saudeCreateManyPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type economiaCreateManyPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type ambienteCreateManyPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type tecnologiaCreateManyPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type demografiaCreateManyPaisInput = {
    id?: number
    valor: number
    ano: number
    indicador_id: string
  }

  export type saudeUpdateWithoutPaisInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador?: indicadorUpdateOneRequiredWithoutSaudeNestedInput
  }

  export type saudeUncheckedUpdateWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type saudeUncheckedUpdateManyWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type economiaUpdateWithoutPaisInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador?: indicadorUpdateOneRequiredWithoutEconomiaNestedInput
  }

  export type economiaUncheckedUpdateWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type economiaUncheckedUpdateManyWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type ambienteUpdateWithoutPaisInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador?: indicadorUpdateOneRequiredWithoutAmbienteNestedInput
  }

  export type ambienteUncheckedUpdateWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type ambienteUncheckedUpdateManyWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type tecnologiaUpdateWithoutPaisInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador?: indicadorUpdateOneRequiredWithoutTecnologiaNestedInput
  }

  export type tecnologiaUncheckedUpdateWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type tecnologiaUncheckedUpdateManyWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type demografiaUpdateWithoutPaisInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador?: indicadorUpdateOneRequiredWithoutDemografiaNestedInput
  }

  export type demografiaUncheckedUpdateWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type demografiaUncheckedUpdateManyWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    indicador_id?: StringFieldUpdateOperationsInput | string
  }

  export type saudeCreateManyIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type economiaCreateManyIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type ambienteCreateManyIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type tecnologiaCreateManyIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type demografiaCreateManyIndicadorInput = {
    id?: number
    valor: number
    ano: number
    pais_id: string
  }

  export type saudeUpdateWithoutIndicadorInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutSaudeNestedInput
  }

  export type saudeUncheckedUpdateWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }

  export type saudeUncheckedUpdateManyWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }

  export type economiaUpdateWithoutIndicadorInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutEconomiaNestedInput
  }

  export type economiaUncheckedUpdateWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }

  export type economiaUncheckedUpdateManyWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }

  export type ambienteUpdateWithoutIndicadorInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutAmbienteNestedInput
  }

  export type ambienteUncheckedUpdateWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }

  export type ambienteUncheckedUpdateManyWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }

  export type tecnologiaUpdateWithoutIndicadorInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutTecnologiaNestedInput
  }

  export type tecnologiaUncheckedUpdateWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }

  export type tecnologiaUncheckedUpdateManyWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }

  export type demografiaUpdateWithoutIndicadorInput = {
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais?: paisUpdateOneRequiredWithoutDemografiaNestedInput
  }

  export type demografiaUncheckedUpdateWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }

  export type demografiaUncheckedUpdateManyWithoutIndicadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    pais_id?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}